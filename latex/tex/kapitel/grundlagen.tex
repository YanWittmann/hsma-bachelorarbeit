\chapter{Grundlagen}\label{ch:grundlagen}


\section{Schwächen und Schwachstellen}\label{sec:def-weakness-vulnerability}

\paragraph{Schwäche (Weakness)}

Der Begriff \enquote{Schwäche} in einer Software-Komponente bezeichnet einen intrinsischen Fehler, Defekt oder eine problematische Eigenschaft, die unter bestimmten Bedingungen in einer Software oder Hardware zu unerwünschtem Verhalten führen kann \autocite{Ross_Winstead_McEvilley_2022}.
Schwächen beschreibende grundlegende Fehlermuster, die unabhängig von spezifischen Implementierungen oder Angriffsszenarien existieren.

Das \acrfull{cwe}-Projekt\footnote{\url{https://cwe.mitre.org/about/index.html}}, unter der Leitung der MITRE Corporation, stellt einen großen Katalog solcher Software-Schwächen dar.
Als Community-getriebenes Projekt ordnet es Schwächen in einem hierarchischen System als \acrshort{cwe}-Einträge an, die verschiedene Abstraktionsebenen abdecken\ \autocite{wu2016cwe}.
Die Klassifikation reicht von abstrakteren Kategorien (\verb+CWE-20+: Improper Input Validation\footnote{\url{https://cwe.mitre.org/data/definitions/20.html}}) bis zu konkreteren Implementierungsfehlern (\verb+CWE-125+: Out-of-bounds Read\footnote{\url{https://cwe.mitre.org/data/definitions/125.html}}).

\paragraph{Schwachstelle (Vulnerability)}

Während Schwächen allgemeine Fehlermuster beschreiben, stellt eine Schwachstelle eine konkrete Ausprägung einer Schwäche in einem spezifischen System oder Produkt dar.
Sie beeinträchtigt die zentralen \acrshort{ciavuln}-Sicherheitsziele (Confidentiality (Vertraulichkeit), Integrity (Integrität) oder Availability (Verfügbarkeit)) und stellen eine Verletzung formeller oder impliziter Sicherheitsanforderungen dar.
Das \acrshort{cve}-Programm, betrieben durch die MITRE Corporation und unterstützt von US-Behörden wie der \acrfull{cisa}, bietet einen weltweit anerkannten Standard zur Identifikation und Beschreibung von öffentlich bekannten Schwachstellen.
Jede Schwachstelle erhält dabei eine eindeutige Kennung (z.B.\ \verb+CVE-2024-12345+) und wird in Kooperation mit autorisierten \acrfull{cna} mit einer Beschreibung der Schwachstelle, Referenzen zu betroffenen Produktversionen, der zugrundeliegende \acrshort{cwe}-Klassifikation sowie einer Bewertung des Schweregrads klassifiziert\ \autocite{Ross_Winstead_McEvilley_2022, CveGlossaryCommonVulnerabilitiesAndExposures12mai2025}.
Die \acrshort{cve} Schwachstellen-Informationen werden über eine \acrshort{api} von der \acrshort{nvd} öffentlich zur Verfügung gestellt\footnote{\url{https://nvd.nist.gov/developers/vulnerabilities}}.

Im Rahmen dieser Arbeit werden ausschließlich \acrshort{cve} als Schwachstellen betrachtet, andere ähnliche Standards werden als \nameref{par:security-advisories} behandelt.

\paragraph{Security Advisories}\label{par:security-advisories}

% OSV, CSAF, etc.
% ich mochte die tabelle aus “Table 2. Security vulnerability databases (VDBs).” (Bennouk et al., 2024, p. 865) A Comprehensive Review and Assessment of Cybersecurity Vulnerability Detection Methodologies


\section{Schachstelldatenbanken}\label{sec:security-vulnerability-databases}

% VDBs
% “3.3. Security Vulnerability Databases” (Bennouk et al., 2024, p. 864) A Comprehensive Review and Assessment of Cybersecurity Vulnerability Detection Methodologies
% auflisten von den unterschiedlichen lieferanten von schwachstellinfos und advisories


\section{Software-Inventare}\label{sec:def-inventories}

Eine \acrfull{sbom} ist ein strukturiertes Inventar aller Software-Komponenten, aus denen ein System oder Produkt besteht.
Sie enthält Informationen über die Namen, Versionen, Lizenzen, Schwachstellen und Abhängigkeiten der Softwarebestandteile, sowie Metadaten wie Copyright-Hinweise oder kryptographische Hashes.
Eine \acrshort{sbom} hat das Ziel, die Transparenz in der Software-Lieferkette mit Informationen über die Herkunft und Zusammensetzung einer Software zu unterstützen, um den Nächsten in der Lieferkette eine Risikobewertung zu ermöglichen oder die Einhaltung von Lizenzbestimmungen nachweisen zu können \autocite{Bi_Xia_Xing_Lu_Zhu_2023}.

Eine \acrshort{sbom} kann sowohl manuell als auch automatisiert durch die Identifikation und Dokumentation aller verwendeten Software-Komponenten erfolgen.
Manuelle Methoden sind jedoch vor allem bei wiederholten Durchläufen inkonsistent, fehleranfällig und in größeren Projekten kaum skalierbar.
Die Aktualisierung von \acrshortpl{sbom} ist nötig, wenn z.B.\ bei neuen Versionen sich die Zusammensetzung einer Software verändert.
Daher wird die Erzeugung von \acrshortpl{sbom} in der Regel projektweit durch Werkzeuge, die Quellcode, Projektdateien oder Container analysieren, durchgeführt \autocite{Bi_Xia_Xing_Lu_Zhu_2023}.

Die Qualität eines Software-Inventars ist für eine erfolgreiche Sicherheitsanalyse wichtig, da die Zuordnung bekannter Schwachstellen zu konkreten Software-Komponenten von der Genauigkeit und Vollständigkeit des Inventars abhängt.
Fehlende oder ungenaue Angaben zu Produktnamen und Versionen können durch die inhaltliche oder formale Abweichung von Produktrepräsentationen zwischen Inventaren und \acrshortpl{vdb} zu falsch-positiven oder falsch-negativen Schwachstellenzuweisungen führen \autocite{Idrissi_Sebai_Faroukhi_Mahouachi_2024}.

Zur einheitlichen Darstellung und Verbreitung solcher Inventare haben sich mehrere maschinenlesbare Standards etabliert.

\paragraph{\acrfull{spdx}}\footnote{\url{https://spdx.dev}}
wurde ursprünglich für das Lizenzmanagement entwickelt und stellt heute einen häufig eingesetzten Standard zur Beschreibung von Software-Inventaren dar.
Der Fokus des Projekts liegt noch immer auf der Darstellung lizenzrechtlicher Informationen, jedoch lassen sich mit \acrshort{spdx} auch Komponenten, Abhängigkeiten und Beziehungen detailliert beschreiben \autocite{spdxOverview1june2024}.
\acrshort{spdx} wird von der Linux Foundation gepflegt und ist unter \texttt{ISO/IEC 5962:2021}\footnote{\url{https://www.iso.org/standard/81870.html}} international standardisiert.

\paragraph{CycloneDX}\footnote{\url{https://cyclonedx.org}}
wurde von der OWASP Foundation in Zusammenarbeit mit Ecma International entwickelt und ist seit 2024 als Standard \texttt{ECMA-424} veröffentlicht \autocite{CycloneDX2024Spec, ecma424:2024}.
CycloneDX beschreibt ein maschinenlesbares Format zur Dokumentation von Software-Komponenten, deren direkten Abhängigkeiten, Lizenzinformationen, kryptografischen Prüfsummen und bekannten Schwachstellen.
Durch die Möglichkeit, eigene Felder und Erweiterungen in den Dokumenten zu verwenden, können domänenspezifische Anforderungen ohne Anpassung des Standards abgedeckt werden.
Neuere Versionen führen Erweiterungen für z.B.\ für Hardware-Komponenten (HBOM)\footnote{\url{https://cyclonedx.org/capabilities/hbom}}, KI-Modelle und Trainingsdaten (AI/ML-BOM)\footnote{\url{https://cyclonedx.org/capabilities/mlbom}} oder Konfigurationen und Betriebsdaten (OBOM)\footnote{\url{https://cyclonedx.org/capabilities/obom}} hinzu.

\paragraph{\metaeffekt-Inventare}
werden im Detail in \autoref{sec:metaeffekt-inventory-format} erklärt.
Durch Konverter-Plugins\footnote{\url{https://gitlab.opencode.de/metaeffekt/metaeffekt-components/-/tree/master}} können Inventare vom und zum proprietären Format der \metaeffektsp von \acrshort{spdx} und CycloneDX konvertiert werden.
Durch den \metaeffektsp Extractor kann die Erzeugung von Inventaren auf Basis von Analysen von Quellcode, Build-Artefakten oder Softwarecontainern automatisiert werden.
Die erzeugten Inventare im \metaeffekt-Format können dann in der Schwachstellenanalyse oder Lizenzklassifikation verwendet werden und dienen als Eingabe in die Prozesse, die in dieser Arbeit entwickelt werden sollen.

% “Table 3. SBOM issue categories” ([Bi et al., 2023, p. 13](zotero://select/library/items/WYCQM3PA)) ([pdf](zotero://open-pdf/library/items/XG7WITCJ?page=13&annotation=LSB777ZB)) Bi_Xia_Xing_Lu_Zhu_2023
%   ganz nette übersicht über die use-cases der SBOM


\section{\acrlongpl{vms}}\label{sec:grundlagen-vms}

Vulnerability Management (Schwachstellenmanagement) beschreibt den wiederkehrenden Prozess zur Erkennung von Sicherheitslücken in IT-Systemen.
Ziel ist es, Schwachstellen vor auslieferung des Systems zu identifizieren, nach Risiko zu bewerten und durch Patches oder Gegenmaßnahmen zu mitigieren.
Der typische Schwachstellenmanagement-Prozess besteht aus vier Hauptphasen: (1) Scanning, (2) Schwachstellenerkennung, (3) Analyse und (4) Reporting.
In der Praxis werden dabei zunächst Schwachstellen durch Abgleich mit bekannten \acrshortpl{vdb} identifiziert und mit Metadaten angereichert, um eine automatisierte Priorisierung und Reihenfolge des Vorgehens abzuleiten, bevor die manuelle Behebung durch Patches oder Workarounds erfolgt und schließlich die Wirksamkeit der Korrekturmaßnahmen überprüft wird \autocite{foreman2019vulnerabilityManagement}.

Schwachstellmanagement als Prozess verwendet somit die priorisierte Liste an Schwachstellen eines Schwachstellenscans, um dann durch manuelle Bewertungsprozesse bis zu einem durch Rahmenbedingungen gesetzen Score-Limit die Schwachstellen auszuwerten und zu bewerten \autocite{foreman2019vulnerabilityManagement}.

Die Identifikation von Schwachstellen ist also nur der erste Schritt in einem vollständigen Schachstellmanagement.
Diesen manuell regelmäßig durchzuführen ist zeitaufwendig, ein \acrshort{vms} automatisiert darum durch den Abgleich mit \acrshortpl{vdb} (wie \acrshort{cve} mit \acrshort{cpe} der \acrshort{nvd}) zur Identifikation von Schwachstellen und der Priorisierung bereits wesentliche aufwendige Schritte des Schwachstellenmanagements \autocite{Idrissi_Sebai_Faroukhi_Mahouachi_2024}.

Die Effektivität eines \acrshort{vms} hängt dabei stark von der Qualität der zugrundeliegenden Software-Inventare und Produktidentifikationsmechanismen ab (vgl. \autoref{sec:def-inventories}).
Einige Mechanismen für die Erkennung von Produkten werden in \autoref{sec:produktidentifikationsstandards-herausforderungen} vorgestellt und es wird festgestellt, dass diese für die genaue Erkennung zu Fehleranfällig sind und es meist einem manuellen Korrekturschritt bedarf.


\section{Produktidentifikationsstandards, Formate und ihre Herausforderungen}\label{sec:produktidentifikationsstandards-herausforderungen}

\subsection{Produkte und ihre Repräsentation}

% erst mal allgemein darüber reden worum es geht
% Name ≠ Identity
% Intrinsic vs extrinsic naming scheme
% warum gibt es so viele formate (jeder sein use-case)

Um Schwachstellmanagement wie in \autoref{sec:grundlagen-vms} beschrieben effektiv durchführen zu können, muss Software in Software-Inventaren auf eine Weise angegeben sein, die eine Korrelation dieser Software mit anderen Informationen wie bekannten Schwachstellen erlaubt.
Das Ziel muss es sein, dass verschiedene Akteure wie Konsumenten von \acrshortpl{vdb}, Inventarwerkzeuge und Sicherheitsexperten mit der Darstellung der Software genau wissen, dass sie über dieselbe Software reden.
In der Realität existieren jedoch viele heterogene Lösungen zur Software-Identifikation, die eine unterschiedliche Granularität oder Fokus haben und sich darum nicht einfach gegenseitig ineinander überführen lassen \autocite{CISA2023}.

Ein grundlegendes Problem bei der Identifikation ist die Unterscheidung zwischen einem \textit{Namen} und einer eindeutigen \textit{Identität} \autocite{Manion_Proell_Schmidt2023}.
Anhand eines Beispiels aus der Chemie:
Natriumchlorid ist eine kubische Kristallstruktur und kann mit \textit{NaCl} als identifizierende Verhältnisformel vollständig nur aufgrund seiner intrinsischen Eigenschaften beschrieben werden.
Allerdings gibt es noch weitere Systeme, wie chemische Stoffe angegeben werden können.
Authoritative Systeme wie CAS-Nummern definieren einen extrinsischen, künstlichen Bezeichner für Stoffe, so etwa \textit{7647-14-5} für Natriumchlorid \autocite{Huebner_2003}.
Die \textit{Identität} ist die eigentliche Zusammensetzung von Natriumchlorid, NaCl und 7647-14-5 sind Namen, die dieser Struktur gegeben wurden.

Ebenso verhält es sich mit Software.
Ein zu benennendes Artefakt kann sich auf eine oder mehrere Dateien beziehen, aber auch auf ein Betriebssystem, Hardware, eine Sammlung an Projekten und weiteren, beliebigen Inhalten.
Die Bezüge der Hersteller zu den Artefakten können jederzeit ändern:
Neue Hersteller treten in den Markt, ziehen sich zurück, werden aufgekauft oder zusammengeführt, aber auch alleine die Projekte können geforkt, archiviert oder aufgegeben werden.
Projekte und Produkte können in komplexen Beziehungen stehen und transformieren sich stets weiter.
Diese Gefüge lassen sich nicht mit den bisherigen häufig eingesetzen Identifikationsstandards abbilden \autocite{Manion_Proell_Schmidt2023}.

Der Begriff \enquote{Produktidentifikationsstandard-Ökosystem} wird wie in \autocite{CISA2023} dazu verwendet, um zu verdeutlichen, dass es nicht einfach ausreicht, ein technisches Format zur Beschreibung von Softwareprodukten zu definieren.
Vielmehr ist ein Ökosystem welches von der Industrie akzeptiert und deren Regeln durchgängig angewendet werden notwendig, das auch Prozesse zur Erstellung, Verbreitung und Nutzung solcher Identifikatoren umfasst.

--- TODO: check but it's quite all right:

Ein solches Ökosystem muss verschiedene Anforderungen erfüllen, um eine effektive Korrelation von Daten – etwa zwischen Software-Inventaren und Schwachstellendatenbanken – zu ermöglichen.
Dabei identifiziert \textcite{CISA2023} zwei zentrale Anforderungen: Erstens müssen Produktidentifikatoren in allen relevanten Kontexten und Zeitpunkten verfügbar sein.
Das bedeutet, dass sowohl beim Erstellen von Inventareinträgen als auch beim Verfassen von Schwachstellenberichten die richtigen Identifikatoren bekannt und zugreifbar sein müssen.
Zweitens muss das Ökosystem unterschiedliche Granularitätsanforderungen unterstützen – von sehr spezifischen Softwarevarianten bis hin zu generischen Produktfamilien.

Die Heterogenität bestehender Identifikationsschemata – wie etwa \acrshort{cpe}, \acrshort{purl} oder interne IDs in proprietären Systemen – erschwert jedoch die breite Korrelation zwischen verschiedenen Datensätzen und Tools.
Während einige dieser Standards in bestimmten Kontexten erfolgreich angewendet werden (z.,B. \acrshort{purl} in Paketmanagern), scheitern sie häufig daran, produktübergreifend und interoperabel eingesetzt werden zu können.
Ein zukunftsfähiges Identifikationssystem muss daher eine flexible Ausdrucksstärke besitzen, um sowohl präzise als auch generische Identifikationen zu ermöglichen, interoperabel einsetzbar sein und durch geeignete Governance-Mechanismen gestützt werden.

Solch ein System würde nicht nur die Effizienz im Schwachstellenmanagement deutlich erhöhen, sondern auch die Grundlage für eine skalierbare Automatisierung im Bereich Software-Sicherheit und Lieferketten-Transparenz schaffen.

\subsection{CPE}

% Sanguino_Uetz_2017
% “2.1. Common Platform Enumeration (CPE) CPE is a method that specifies a naming scheme for applications, hardware devices, and operating systems. CPE is part of the Security Content Automation Protocol (SCAP)5 standard, which was proposed by the National Institute of Standards and Technology (NIST). Currently, there exist two versions of the CPE specification: CPE 2.2 and CPE 2.3. Version 2.3 defines a stack formed by five specifications, including the CPE naming specification [4] and the CPE dictionary specification [5].” (Sanguino and Uetz, 2017, p. 3)
% “3. CPE Dictionary and CVE Feeds Analysis” “This section discusses issues that we found in the official CPE dictionary9 and CVE feeds10” (Sanguino and Uetz, 2017, p. 6)
% the above paper also talks quite well about CVE

\paragraph{Probleme mit CPE}

% Probleme mit CPE:
% “3.1. CVE entries without CPE entries” (Sanguino and Uetz, 2017, p. 7) Sanguino_Uetz_2017
%       Found [40652 / 291389] vulnerabilities that do not have any vulnerable software configurations
% “3.2. Software Products without assigned CPE” (Sanguino and Uetz, 2017, p. 7)
% “3.3. CPE Dictionary Deprecation Process” (Sanguino and Uetz, 2017, p. 8)
% “When CVE matches for a software product are found, IVA does not automatically generate alerts. The user must confirm that a CVE is indeed a vulnerability for the software product.” (Sanguino and Uetz, 2017, p. 23)
%       notwendigkeit dass man manuell daran arbeiten muss
% man kann sie nicht einfach erraten, weil sie nicht einer konvention folgen:
%       “However, some CPE-IDs registered in the dictionary may not follow the nomenclature rules of CPE specification. For instance, Hidemaru’s CPE-ID violated the rules at the time of this writing.” (Takahashi et al., 2016, p. 4) Takahashi_Miyamoto_Nakao_2016
% python pthyon

\paragraph{Identifikation von CPE}\label{par:automated-cpe-identification}

% “Table 3. Collected methods related to the similarity matching-based approach.” (Bennouk et al., 2024, p. 870) A Comprehensive Review and Assessment of Cybersecurity Vulnerability Detection Methodologies
% “In the first step, CPE identifiers that could be assigned to a software product (CPE candidates) are searched for.” (Sanguino and Uetz, 2017, p. 10) Sanguino_Uetz_2017
%    “5.2.1. CPE Matching As can be seen in Table 3, IVA would be able to automatically assign the correct CPEs to ten products; however, to the products P6 and P11 incorrect CPEs would be assigned.” (Sanguino and Uetz, 2017, p. 19) Sanguino_Uetz_2017
% “Because we typically find only a few exact matches, we use a numerical method to determine a CPE-ID. We introduce a parameter, called matching rate, which is calculated as the percentage of the characters that match the query.” (Takahashi et al., 2016, p. 3) Takahashi_Miyamoto_Nakao_2016
%    “We choose the CPE-ID that shows the highest matching rate, although we judge that no CPE-ID is found if we do not find a CPE-ID with matching rate higher than a certain threshold value.” (Takahashi et al., 2016, p. 3) Takahashi_Miyamoto_Nakao_2016
% “The novelty of this research consists in the algorithm for mapping software names in the information system to the CPE entries based on the Ratcliff/Obershelp algorithm recursively implemented for the software product name’s parts.” (Ushakov et al., 2021, p. 353) Ushakov_Doynikova_Novikova_Kotenko_2021
%    “Research work Method CPE fields Disadvantages Gawron et al., 2017 [6] Regular expression. Name and version Not unified entries or entries with errors are not mapped Sanguino and Uetz [7, 8] Levenshtein algorithm to select CPE candidates based on vendor and name, distance should be less than 2. Versions are used to prioritize the candidates. Vendor, name, and version Requires manual selection from several CPE candidates to avoid errors. Evaluation on 12 products. O'Hare and Macfarlane, 2018 [9] Levenshtein algorithm applied to the CPE list. Candidates with the minimum distance are selected (consequently, 0, 1, or 2). Full entry Error-prone. Na et al., 2017 [10] Hierarchical tree based on entry fields, full words comparison Full entry Error-prone, no evaluation. Bela and Enachescu, 2015 [11] Multiple hierarchical trees Full entry Error-prone” (Ushakov et al., 2021, p. 354) Ushakov_Doynikova_Novikova_Kotenko_2021
%    basically eine zusammenfassung von untersch. papers zum thema

\subsection{PURL}

\subsection{MSRC Product-Ids}

\subsection{EOL Product-Ids}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% somewhere else
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% “Rule #1 Partition by supplier” (Manion et al., p. 18)
% \citeauthor{Manion_Proell_Schmidt2023} erkennen, dass diese Gefüge sich nicht mit den bisherigen häufig eingesetzen Identifikationsstandards abbilden lassen können.
% Sie schlagen vor,
