\section{Beispielhafte Anwendung}\label{sec:beispiele-fertige-implementierung}

Zur Validierung des implementierten Systems werden die vier Referenzfälle aus \autoref{sec:reference-case-chapter} im neuen Format abgebildet.
Jedes Beispiel zeigt spezifische Aspekte des neuen Modells.

\subsection{Referenzfall 1: JavaScript-Paket}\label{subsec:example-js-package}

Der ursprüngliche Fall in \autoref{par:reference-case-walletconnect} zeigte die Herausforderung, ein NPM-Paket mit drei alternativen Namensformen zu identifizieren.
Im alten System waren drei Selektoren mit wiederholenden Attributen nötig, wobei die Typerkennung durch einen regulären Ausdruck passieren musste.
Das neue Modell, wie in \autoref{lst:new-correlation-walletconnect} gezeigt, löst dies durch:

\begin{itemize}
    \itemsep0em
    \item Klare Trennung von Identifikation (\texttt{artifact}) und einer zentralen Produktdefinition (\enquote{NPM React Walletconnect})
    \item Typspezifische Attributerkennung via \texttt{type: npm} ohne Verwendung von regulären Ausdrücken
    \item Mehrfachwerte im \texttt{name}-Attribut (ODER-Verknüpfung)
\end{itemize}

Die Graphstruktur in \autoref{fig:example-graph-walletconnect} zeigt die direkte Verbindung zwischen Artefakt, Produkt und \acrshort{cpe} ohne Redundanz in den Attributen.
Weitere Metadaten können optional ergänzt werden.

\begin{lstlisting}[style=yaml,caption={Produktmodellierung zu react-walletconnect},label={lst:new-correlation-walletconnect},basicstyle=\ttfamily\scriptsize]
- cpe: "cpe:/a:uniswap:web3-react_walletconnect"

- product: "NPM React Walletconnect"
  is: [ cpe: "a:uniswap:web3-react_walletconnect" ]

- artifact: "npm react walletconnect"
  identification:
    - type: npm
      name: [ "web3-react_walletconnect", "walletconnect", "@web3-react/walletconnect" ]
  is: [ product: "NPM React Walletconnect" ]
\end{lstlisting}

\begin{figure}[htbp]
    \centering
    \makebox[\textwidth]{\includesvg[width=1.3\textwidth, inkscapelatex=false]{bilder/example-graph-walletconnect}}
    \caption{Generierter Graph zu react-walletconnect}
    \label{fig:example-graph-walletconnect}
\end{figure}

\subsection{Referenzfall 2: Java-Runtimes}\label{subsec:example-java-runtimes}

Wie im Referenzfall in \autoref{par:reference-case-java-runtimes} beschrieben, erforderte die Versionstransformation bei Java-Runtimes im alten System pro zu unterstützende Version einer Runtime jeweils einen redundanten Eintrag mit sich wiederholenden Informationen.
Das neue Modell in \autoref{lst:new-correlation-java-runtimes} adressiert diese Herausforderungen durch:

\begin{itemize}
    \itemsep0em
    \item Nur ein einziger Knoten für jede \acrshort{cpe}-Repräsentation und das Artefakt
    \item Versionstransformation im zentralen Produktknoten mit Artefakt-Versionsmustern wie \verb|/1\.1\.6[^0-9].*9/| für die Konvertierung nach zu \acrshort{cpe}-Versionen wie \texttt{1.1.6\_009}
    \item Ein Namespace \enquote{corretto (artifact to cpe)} kapselt diese Transformationsregeln, sodass sie optional verwendet werden können
    \item Statt drei Eigenschaften mit regex-basierter Erkennung aus der \texttt{Id} auszulesen, wird über eine explizite Typisierung (\texttt{type: java-runtime}) das \texttt{supplier}-Attribut programmatisch bereitgestellt und die Version wird explizit später geprüft
\end{itemize}

Der resultierende Graph in \autoref{fig:example-graph-java-runtimes} zeigt, wie die Versionstransformationen von einzelnen Einträgen auf einen einzigen Produktknoten gewandert sind.
Die im alten System notwendigen redundanten Einträge werden durch diese Struktur ersetzt.

\begin{lstlisting}[style=yaml,caption={Produktmodellierung zu Amazon Correto},label={lst:new-correlation-java-runtimes},basicstyle=\ttfamily\scriptsize]
- cpe: "cpe:/a:amazon:corretto"
  namespace: "corretto (artifact to cpe)"
- cpe: "cpe:/a:oracle:jdk"
  namespace: "corretto (artifact to cpe)"
- cpe: "cpe:/a:oracle:jre"
  namespace: "corretto (artifact to cpe)"

- artifact: "java runtime amazon-corretto base identification"
  namespace: "corretto (artifact to cpe)"
  identification:
    - type: java-runtime
      supplier: "AMAZON_CORRETTO"
  is: [ product: "Amazon Corretto Java Runtime" ]

- product: "Amazon Corretto Java Runtime"
  namespaces:
    "corretto (artifact to cpe)":
      - source: [ version: "/1\\.1\\.6[^0-9](.*[^0-9])?0*9([^0-9].*)?/i" ]
        target: [ version: "1.1.6_009" ]
      - source: [ version: "/1\\.1\\.6[^0-9](.*[^0-9])?0*8([^0-9].*)?/i" ]
        target: [ version: "1.1.6_008" ]
  is:
    - cpe: "a:amazon:corretto"
    - cpe: "a:oracle:jdk"
    - cpe: "a:oracle:jre"
\end{lstlisting}

\begin{figure}[htbp]
    \centering
    \makebox[\textwidth]{\includesvg[width=1.3\textwidth, inkscapelatex=false]{bilder/example-graph-java-runtimes}}
    \caption{Generierter Graph zu Amazon Correto}
    \label{fig:example-graph-java-runtimes}
\end{figure}

\subsection{Referenzfall 3: Redis}\label{subsec:example-redis}

Der in \autoref{par:reference-case-redis} beschriebene Redis-Fall zeigt die Herausforderung von überladenen Artefaktbezeichnern, bei denen der gleiche Basisname \texttt{redis-*} sowohl die Datenbankserver-Software als auch ein Python-Client-Modul repräsentiert.
Im alten System (\autoref{lst:correlation-order-depdendency-example}) waren dafür Reihenfolgeabhängige \texttt{remove}-Regeln nötig.
Im neuen Korrelationssystem werden die Herausforderungen gelöst, wie in \autoref{lst:new-correlation-redis} im Modifikationsformat zu sehen.

\begin{itemize}
    \itemsep0em
    \item Explizite Trennung in zwei Produktknoten (\enquote{Redis DB} und \enquote{Redis Python Interface})
    \item Statt doppelter Auflistung von der DB-\acrshort{cpe} bei dem Python Interface wird eine einzige \texttt{is not}-Relation zur Angabe der falschen \acrshort{cpe} angegeben
    \item Typspezifische Identifikation des Python-Moduls via \texttt{type: python}
    \item Dokumentation über Knotenmetadaten
\end{itemize}

Der sich daraus ergebende Graph in \autoref{fig:example-graph-redis} zeigt die klare Trennung der Produkte, die im alten System nur implizit durch die Reihenfolge der Einträge definiert war.

\begin{lstlisting}[style=yaml,caption={Produktmodellierung zu Redis},label={lst:new-correlation-redis},basicstyle=\ttfamily\scriptsize]
- cpe: "cpe:/a:redis:redis"
  metadata:
    description: "For developers, who are building real-time data-driven [...]"
    references:
      homepage: https://redis.io
      repository: https://github.com/redis/redis
- cpe: "cpe:/a:redislabs:redis"
- cpe: "cpe:/a:pivotal_software:redis"

- cpe: "cpe:/a:redis:redis-py"

- product: "Redis DB"
  is:
    - cpe: "a:redis:redis"
    - cpe: "a:redislabs:redis"
    - cpe: "a:pivotal_software:redis"

- product: "Redis Python Interface"
  is: [ cpe: "a:redis:redis-py" ]

- artifact: "Redis DB"
  identification:
    - name: "redis/i"
  is: [ product: "Redis DB" ]

- artifact: "Redis Python Interface"
  identification:
    - type: python
      name: "redis"
  is: [ product: "Redis Python Interface" ]
  is not: [ product: "Redis DB" ]
\end{lstlisting}

\begin{figure}[htbp]
    \centering
    \makebox[\textwidth]{\includesvg[width=0.8\textwidth, inkscapelatex=false]{bilder/example-graph-redis}}
    \caption{Generierter Graph zu Redis}
    \label{fig:example-graph-redis}
\end{figure}

\subsection{Referenzfall 4: Windows 10}\label{subsec:example-windows}

Das Szenario in \autoref{par:reference-case-windows} zeigt die Abbildung von hierarchischen Betriebssystemstrukturen im alten Modell.
Im alten System mussten einzelne Versionen und Architekturunterschiede jeweils separat mit duplizierten Basisinformationen modelliert werden.

Im neuen Modell in \autoref{lst:new-correlation-windows} wird diese Komplexität über eine mehrstufige Struktur mit Vererbung und Ausschlussregeln modelliert.
Die Basisdefinition von Windows 10 wird mit den relevanten Attributen als eigenständiger Knoten definiert.
Versions- und architekturabhängige Merkmale wie \texttt{21H2}, \texttt{amd64} oder \texttt{x86} werden als eigene Knoten mit einer Vererbungskante zu der jeweils darunter liegenden Identifikation geführt.
Jede Artefakt-Identifikation besitzt einen zugehörigen Produktknoten, der diese Ausprägung der Attributkombinationen darstellt.
Über diese Produkte sind die weiteren Repräsentationen erreichbar.
Die negatividentifikation von Komponenten wie der Media Player kann durch \texttt{is not}-Relationen ausgeschlossen werden.

Ein wichtiger Fall ist die Kante von \enquote{Windows 10 21H2} zu \enquote{o:microsoft:windows\_10\_21h2}, bei der eine Transformation des Versionsattributs angewendet wird.
Da in dem Algorithmus zum Auflösen der erreichbaren Knoten von einem Knoten aus bei mehreren Wegen zu einem Knoten immer die spezifischste (in der Vererbungshierarchie oben liegende) Kante gewählt wird, wird bei einem Match des Knotens \enquote{Windows 10 21H2} trotz der Erreichbarkeit des \acrshort{cpe}-Knotens über das Basisprodukt \enquote{Windows 10} nicht die Basiskante unten gewählt, sondern die spezifische oben mit der Transformation.
Dieses Verhalten kann im resultierenden Graph in \autoref{fig:example-graph-windows} beobachtet werden.

\begin{lstlisting}[style=yaml,caption={Produktmodellierung zu Windows 10},label={lst:new-correlation-windows},basicstyle=\ttfamily\scriptsize]
- cpe: "cpe:/a:windows:media_player"
- cpe: "cpe:/o:microsoft:windows"
- cpe: "cpe:/o:microsoft:windows_10_21h2"
- cpe: "cpe:/o:microsoft:windows_10"

- ms: "11929"
- ms: "11931"

- eol: "windows"

- product: "Windows 10"
  is:
    - cpe: "o:microsoft:windows_10"
    - eol: "windows"
  is not:
    - cpe: "a:windows:media_player"
    - cpe: "o:microsoft:windows"

- product: "Windows 10 21H2"
  is:
    - cpe: "o:microsoft:windows_10_21h2"
    - cpe: "o:microsoft:windows_10"
      transform:
        - version: 21h2
    - eol: "windows"
    - ms: "11931"
  inherit: [ product: "Windows 10" ]

- product: "Windows 10 21H2 32bit"
  is: [ ms: "11929" ]
  inherit: [ product: "Windows 10 21H2" ]

- product: "Windows 10 21H2 64bit"
  is: [ ms: "11931" ]
  inherit: [ product: "Windows 10 21H2" ]

- artifact: "Windows 10"
  identification:
    - type: operating system
      attributes:
        Id: [ "Microsoft Windows 10*", "Windows 10*" ]
  is: [ product: "Windows 10" ]
  metadata:
    description: "The base microsoft Windows 10 identification"
    references:
      release information: https://learn.microsoft.com/de-de/windows/release-health/release-information

- artifact: "Windows 10 21H2"
  identification:
    - version: "10.0.19044*"
  is: [ product: "Windows 10 21H2" ]
  inherit: [ artifact: "Windows 10" ]

- artifact: "Windows 10 21H2 32 bit"
  identification:
    - attributes:
        Architecture: "*32*"
  inherit: [ artifact: "Windows 10 21H2" ]
  is: [ product: "Windows 10 21H2 32bit" ]

- artifact: "Windows 10 21H2 64 bit"
  identification:
    - attributes:
        Architecture: "*64*"
  inherit: [ artifact: "Windows 10 21H2" ]
  is: [ product: "Windows 10 21H2 64bit" ]
\end{lstlisting}

\begin{figure}[htbp]
    \centering
    \makebox[\textwidth]{\includesvg[width=1.3\textwidth, inkscapelatex=false]{bilder/example-graph-windows-10}}
    \caption{Generierter Graph zu Windows 10}
    \label{fig:example-graph-windows}
\end{figure}

\subsection{Zusammenfassung}\label{subsec:example-results}

Die vier Referenzfälle konnten allesamt auf das neue Korrelationssystem überführt werden.
Bei allen Fällen hat diese Konvertierung zu einer Verbesserung der Modellierung geführt, die Fehlerresistenter ist und weniger Redundanz aufweist.
