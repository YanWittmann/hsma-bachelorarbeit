\section{Modell des neuen Korrelationssystems}\label{sec:model-modellierungsansatz}

Basierend auf den abgeleiteten Anforderungen und den analysierten Referenzfällen wird in den nachfolgenden Kapiteln das Modell des neuen Korrelationssystems vorgestellt.
Dieses umfasst die Graphenstruktur, ein Modifikationssystem zur Transformation des Graphen, das zugehörige \acrshort{yaml}-Format für manuelle Modifikationen sowie die Matching- und Traversierungsregeln, die für die Auswertung von Repräsentationsauflösungen notwendig sind.

\subsection{Struktur des Graphen}\label{subsec:model-graph-struktur}

Wie in den Anforderungen \hyperref[subsec:req-format-product-graph]{A-01} und \hyperref[subsec:req-product-concept]{A-04} festgelegt, wird das neue Korrelationssystem als Graph modelliert.
In dieser Struktur entspricht jeder Knotenpunkt entweder einem Produkt oder einer spezifischen Repräsentation dieses Produktes.
Die Knoten werden durch Kanten verbunden, welche die semantischen Beziehungen zwischen ihnen abbilden.

\subsubsection{Knotenpunkte}\label{subsubsec:model-graph-knoten}

Knotenpunkte sind grundlegend typisiert, wobei ihr Typ Auskunft über zusätzliche Attribute und Eigenschaften gibt.
Zunächst werden die Typen der Produktrepräsentationen betrachtet, wobei für jedes Produktidentifikationsökosystem ein eigener Typ definiert wird.
Ein Typ legt fest, wie sich ein Knoten selbst identifiziert und wie er mit realen Repräsentationen abgeglichen wird, um eine Übereinstimmung mit einem Knoten festzustellen.
In der Auswertungsphase bestimmt die Kombination aus dem Knotentyp und dem Typ einer eingehenden Kante zudem, welchen Effekt er auf Eingabedaten hat.

Um die in \hyperref[subsec:req-node-id-type]{A-02} geforderte Eindeutigkeit eines Knotens sicherzustellen, besitzt jeder Knoten im Datenmodell zusätzlich zu seinem Typ eine Id.
Die Kombination aus Typ und Id ermöglicht eine eindeutige Adressierung eines Knotens im Graphen.
Nach \hyperref[subsec:req-unique-product-representations]{A-05} darf sich jede Repräsentation in nur einem Knoten ausprägen und muss zur Wiederverwendung über gerichtete Kanten angesprochen werden.

Die initial geplanten Knotentypen und deren Attribute und Verhalten können in der folgenden Liste betrachtet werden.
Der Typ des Produkt-Knotenpunkts wird in \autoref{subsubsec:model-product-node} beschrieben.
Um von Anfang an ein einheitliches Format für die Ids unterschiedlicher Typen zu sichern, wird zudem auch eine Regel angegeben, wie aus einer Repräsentation eine kanonische Id abgeleitet werden kann.

\begin{itemize}
    \itemsep0em
    \item \textit{\acrshort{cpe}}: repräsentieren genau eine \acrshort{cpe} mit einer Menge an gesetzten Attributen, beispielsweise \texttt{cpe:/a:redis:redis}.
    Wenn ein solcher Knoten über eine \enquote{is}-Beziehung von einem Artefakt aus erreicht wird, wird die entsprechende \acrshort{cpe} dem Ziel-Artefakt als \texttt{Additional CPE URIs} hinzugefügt, und von \texttt{Inapplicable CPE URIs} entfernt.
    Bei \enquote{is not} passiert entsprechend das Gegenteil.
    Die kanonische Id eines \acrshort{cpe}-Knotens leitet sich aus der Menge an Doppelpunkt-getrennten Attributen ab, die in der \acrshort{cpe} gesetzt sind, wobei Lücken zwischen gesetzten Attributen immer mit \enquote{*} aufgefüllt werden müssen.
    Zu der beispielhaften redis-\acrshort{cpe} wäre die Id entsprechend: \texttt{a:redis:redis}.
    \item \textit{\acrshort{purl}}: verhält sich ähnlich wie ein \acrshort{cpe}-Knoten, es werden die Attribute einer \acrshort{purl} abgelegt.
    Bei \acrshortpl{purl} wird für die Knoten-Id die Attributmenge der \acrshort{purl} selbst in kanonischer Reihenfolge ohne den \texttt{pkg:}-Präfix verwendet.
    \item \textit{MS Product ID}: stellen eine numerische Produkt-Id dar, und können optional anzuwendende KB-Nummern (Security-Patch Ids) enthalten.
    Ähnlich wie bei dem \acrshort{cpe}-Knoten werden Artefakten bei positiver oder negativer Übereinstimmung die Ids in dem Attribut \texttt{MS Product Id} hinzugefügt oder entfernt.
    Die Knoten-Id ist identisch mit der Produkt-Id.
    \item \textit{\acrshort{eol}-Id}: enthält genau eine Produkt-Id aus dem endoflife.date-Ökosystem und optional eine Referenz auf einen Zyklus innerhalb dieses Produkts.
    Die Knoten-Id ist identisch mit der Produkt-Id.
    \item \textit{Artefakt}: repräsentieren tatsächliche Software-Artefakte, die in einem Inventar aus einem Software-Scan oder einer \acrshort{sbom} gefunden werden können.
    In dem Nutzungskontext der Korrelationsdaten dienen sie als Ausgangspunkt für den Selektionsprozess und die anschließende Graphen-Traversierung um Effekte auf ein Artefakt zu bestimmen.
    Ein Artefakt-Knoten besitzt einen Selektionsblock, der die Kriterien für die Artefakt-Selektion enthält.
    Die Selektionslogik wird in \autoref{subsubsec:model-matching} genauer ausgeführt.
\end{itemize}

Jeder Knoten, und jede Kante, soll zudem Metadaten über sich selbst speichern können, wie in \autoref{subsec:model-rationale} näher erläutert wird.

Das neue Korrelationssystem basiert also auf einem Graphenmodell mit klar definierten Knoten und Kanten, um Repräsentationen nachvollziehbar zu verknüpfen.
Jeder Knoten repräsentiert eine eindeutige Produkt- oder Repräsentation mit typspezifischen Attributen und einer Id, die eine genaue Identifikation und die weiteren Anforderungen der Traversierung und Transformation ermöglicht.

\subsubsection{Kanten}\label{subsubsec:model-edges-relations}

Die Kanten des Graphen sind gerichtete Beziehungen zwischen den Knotenpunkten und modellieren die logischen Verknüpfungen innerhalb des Korrelationssystems.
Die zwei primären Kantentypen sind \enquote{is} und \enquote{is not}, deren Interpretation bei dem Zielknoten liegt, jedoch allgemein das Folgende gilt:

Die \enquote{is}-Kante (auch \enquote{is represented by}) drückt eine Zugehörigkeitsbeziehung aus.
Allgemein beschreibt sie, dass eine bestimmte Repräsentation die Ausgangsrepräsentation vollständig in einem anderen Ökosystem darstellt und für Anfragen in diesem verwendet werden kann.
Die \enquote{is not}-Kante (auch \enquote{is not represented by}) ist für einen expliziten Ausschluss der Anwendbarkeit einer Repräsentation auf einer Ausgangsrepräsentation zuständig und so Fehlidentifikationen explizit zu vermeiden.
So wird beispielsweise die positiv anwendbare Verknüpfung von Artefakt-Knoten mit Produkt-Knoten, und von Produkt-Knoten mit verschiedenen Standard-Identifikatoren (\acrshortpl{cpe}, \acrshortpl{purl}, etc.) über \enquote{is}-Kanten realisiert, oder wenn ein Artefakt mit einem bestimmten Namen fälschlicherweise einer Produktfamilie zugeordnet werden könnte, kann eine \enquote{is not}-Kante die korrekte Trennung sicherstellen.

Beim Durchqueren des Graphen sind diese beiden Kantentypen jedoch nicht äquivalent auszuwerten, wie genauer in \autoref{subsubsec:model-traversal} beschrieben wird.

Darüber hinaus existiert eine dritte Art von Kante, die eine Vererbung von Informationen repräsentiert (inheritance, \hyperref[subsec:req-selektor-inheritance]{A-07}).
Über diese sollen Basis-Eigenschaften von einem Eltern-Knoten an einen Kind-Knoten weitergegeben werden, mit dem Ziel, die Redundanz im Datenmodell zu reduzieren und die Pflege zu vereinfachen.
Im Stand dieser Arbeit sind zwei Anwendungsfälle für diese vorgesehen.
Mit der Verwendung dieses Kantentyps zwischen Artefakt-Knotenpunkten müssen zum erfolgreichen Matching eines Knotens auch alle darüberliegenden Knotenpunkte erkannt werden.
Bei der Auswahl der übereinstimmenden Artefakt-Knoten wird nur der spezifischste ausgewählt.
Der zweite Nutzungsfall sind Produkt-Knotenpunkte, bei denen auch alle geerbten Kanten zu anderen Knotenpunkten ausgewertet werden.
Eine Prüfung auf zirkuläre Vererbungs-Referenzen ist dabei nötig, um Schleifen zu verhindern und eine eindeutige Auflösung zu garantieren (\hyperref[subsec:req-graph-inner-consistency]{A-19}).

Falls es nötig ist, eine bidirektionale Beziehung darzustellen, kann mit einer identische, umgekehrten Kante die Richtung auf beide Seiten erweitert werden.

\medskip

Zur einheitlichen Visualisierung der Graphen in dieser Arbeit wird im Folgenden eine konsistente Darstellungsform beschrieben und in \autoref{fig:example-graph-node-explanation} beispielhaft veranschaulicht.

Knotenpunkte werden als vertikal unterteilte Rechtecke dargestellt, deren Farbe vom Knotentyp abhängig ist.
Der Knotentyp wird in der obersten Zeile aufgeführt, wie \texttt{cpe} oder \texttt{artifact}.
Direkt darunter folgt die Knoten-Id, die in Kombination mit dem Typ im Graphen eindeutig ist.
Optional darunterliegende Abschnitte enthalten typspezifische Attribute, wie die Selektionskriterien bei Artefakt-Knoten.

Die Relationen zwischen den Knoten werden durch gerichtete Kanten als Pfeile visualisiert.
Jeder Pfeil trägt eine Beschriftung, die den Beziehungstyp definiert.
Weitere Kantenattribute werden ebenfalls in der Beschriftung aufgeführt.

\begin{figure}[htbp]
    \centering
    \makebox[\textwidth]{\includesvg[width=0.45\textwidth, inkscapelatex=false]{bilder/example-graph-node-explanation}}
    \caption{Modellierung einer Artefakt-Zuordnung durch eine positive \texttt{is}- und eine ausschließende \texttt{is not}-Beziehung. In einer realen Modellierung würde ein Produkt-Knoten zwischen den Repräsentationen liegen.}
    \label{fig:example-graph-node-explanation}
\end{figure}

\subsubsection{Produkt-Knoten}\label{subsubsec:model-product-node}
Produkt-Knoten sind eine spezielle Form von Knoten, die ein Software-Produkt wie in \autoref{subsec:produkte-vs-reprasentation} detailliert darstellen.
Sie enthalten im Gegensatz zu den konkreten Repräsentationsknoten keine Selektoren oder Informationen darüber, wie eine Repräsentation modifiziert werden soll, sondern dient als logische Klammer und zentraler Knoten für alle Repräsentationen, mit denen ein Produkt identifiziert werden kann.
So sollen Repräsentationen nicht direkt miteinander über Kanten verbunden werden, sondern über einen Zwischen-Produkt-Knoten, der sie und potenziell weitere verbindet.
Produkt-Knoten stellen eine abstrakte zentrale Einheit dar, an der Repräsentationen aggregiert werden und durch Metadaten (z.\,B. Versionsräume) zu einer einheitlichen Produktdefinition ergänzt werden.

Ein einfaches Beispiel für einen Produktknoten, der eine \acrshort{cpe} als \enquote{anwendbar} kennzeichnet, kann in \autoref{fig:example-graph-simple-log4j} gefunden werden.

\begin{figure}[htbp]
    \centering
    \makebox[\textwidth]{\includesvg[width=0.45\textwidth, inkscapelatex=false]{bilder/example-graph-simple-log4j}}
    \caption{Beispielgraph mit einen Produkt-Knoten und einem Artefakt-Knoten zu Log4J}
    \label{fig:example-graph-simple-log4j}
\end{figure}

Ausschlussbeziehungen zwischen Produkten werden durch \enquote{is not}-Kanten modelliert, die von einem Produkt-Knoten auf einen anderen Produkt-Knoten zeigen.
Eine solche Kante drückt aus, dass alle mit dem Ziel-Produkt-Knoten verknüpften Repräsentationen im Kontext des Ausgangsknotens als unzutreffend zu interpretieren sind.
Dies erlaubt es einfach eine komplizierte semantische Aussage über die Beziehungen von Repräsentationen auf der Basis explizit formulierter Produktausschlüsse zu formulieren.
Die Nicht-Anwendbarkeit wird also durch den Graphen propagiert.

Ein Beispiel für diese Art der \enquote{is not}-Kantenverwendung ist in \autoref{fig:example-graph-cloudfoundry} zu sehen.
Darin wird einem Produkt-Knoten \enquote{Cloudfoundry CLI} die zugehörigen Repräsentationen mit einer \acrshort{cpe} und einem Artefakt zugeordnet.
Daneben wird ein weiterer Produkt-Knoten \enquote{CF Cloud Controller}, ebenfalls mit einer \acrshort{cpe} und einem Artefakt, angelegt.
Gleichzeitig wird im Produkt-Knoten \enquote{CF Cloud Controller} über eine \enquote{is not}-Relation zu \enquote{Cloudfoundry CLI} ein expliziter Ausschluss aller darüber erreichbaren Repräsentationen angegeben.
Dies bewirkt, dass bei der Identifikation des Cloud-Controller-Artefakts über die Traversierung beider Produkt-Knoten die CLI-\acrshort{cpe} als unzutreffend markiert wird, und nur die \acrshort{cpe} des Cloud Controllers bleibt durch die direkte \enquote{is}-Relation weiterhin gültig.

\begin{figure}[htbp]
    \centering
    \makebox[\textwidth]{\includesvg[width=1.3\textwidth, inkscapelatex=false]{bilder/example-graph-cloudfoundry}}
    \caption{Beispielgraph Cloudfoundry mit \enquote{is not}-Kante}
    \label{fig:example-graph-cloudfoundry}
\end{figure}

Um zu vermeiden, dass ähnlich wie im alten Korrelationssystem potenziell viele versionierte Ausprägungen einer gleichen Repräsentation als Knotenpunkte erstellt werden müssen, mit dem Ziel versionierte \acrshortpl{cpe} zu Artefakten zuordnen zu können, müssen Produkt-Knoten in der Lage sein, neben den normalen Begründungen und Referenzen auch weitere Metainformationen über die zugehörigen Repräsentationen abzulegen.
Insbesondere betrifft dies Informationen über Versionsräume und die Mechanismen, wie zwischen diesen konvertiert werden kann.

Diese Ansammlung an Metadaten zusammen mit den Kanten zu Produktrepräsentationen soll zu einem einheitlich aggregierten Produktkonzept führen.

\subsubsection{Namensräume und Transformationen}\label{subsubsec:model-namespaces-transformations}

Jeder Knotenpunkt kann optional eine Menge an \enquote{Namespaces} als eine Liste an Labels zugewiesen bekommen.
Diese Namespaces können auf beliebige Nutzungsfälle erweitert werden, sind im Moment jedoch ausschließlich für das Filtern von Transformationen geplant, die in diesem Kapitel erklärt werden.

Da eine Repräsentation im Graphen in nur einem Knoten ohne Wiederholung ausgeprägt sein soll, müssen Attribute wie Versionen oder Editionen für den Zielknoten aus dem Weg von dem selektierten Knoten zur Zielrepräsentation abgeleitet werden.
Dies wird durch \enquote{transform}-Anweisungen gelöst, die allgemein auf Kanten, aber auch speziell auf Produkt-Knoten angebracht sein können und dementsprechend unterschiedlich ausgewertet werden.
Eine Transformation besitzt immer einen Anwendbarkeitsfilter, der auf Quell- und Zielknoteneigenschaften prüfen kann, und einen Effekt, der auf den Zielknoten bei erfolgreicher Prüfung beider Knoten angewendet werden kann, und eine Transformation, die auf einen Zielknoten angewendet werden soll.

Auf Kanten wird eine vereinfachte Form der Filtermechanismen eingesetzt, da hier die Quelle bereits bekannt ist und so nur noch auf das Ziel gefiltert werden muss.
Auf Produkt-Knoten können beide geprüft werden.
Filterattribute können der Typ, die Id, diverse typspezifische Attribute oder die Zugehörigkeit zu einem Namespace sein.
Sobald ein Transformationseintrag als zutreffend klassifiziert ist, werden an den Zielknoten die weiteren frei setzbaren Attribute des Eintrages weitergegeben, die dieser je nach Knotentyp und Kantentyp individuell auswerten kann.
Beispiele dafür sind bei \texttt{cpe}-Knoten die Attribute wie \texttt{version} oder \texttt{update}.

Auf diese Weise müssen Attribute nicht bereits in dem Knoten der Repräsentation modelliert sein, sondern können auf dem Weg von einer anderen Repräsentation dynamisch gesammelt werden.
Neben diesen freien Attributen gibt es auch noch weitere spezielle Schlüsselwörter, mit denen eine Zielrepräsentation völlig ignoriert werden kann (\texttt{discard}) oder der eingehende Kantentyp explizit gesetzt werden kann (\texttt{is}, \texttt{is not}).

Die Transformationen auf Produkt-Knoten sind unter Anderem eine Lösung für \hyperref[subsec:req-unique-product-representations]{A-05}, welche verlangt, dass eine Repräsentation im Graphen in nur einem Knoten ausgeprägt sein darf.
So können mehrere versionierte Varianten eines Knotens durch einen einzigen generischen ersetzt werden, und die Versionen als Transformationen auf einem dazwischenliegenden Produkt-Knoten ergänzt werden.

\subsection{Dokumentation von Entscheidungen und Produkteigenschaften}\label{subsec:model-rationale}

Dieser Abschnitt teilt sich in zwei Unterkapitel, die das Format der Dokumentation von Metadaten auf Knoten und von Begründungen auf Kanten beschreiben.
Die neuen Formate werden anhand von häufigen Mustern definiert, die aus dem bestehenden Datensatz identifiziert wurden.

\subsubsection{Begründungsfelder auf Kanten}

In \hyperref[subsec:c-05-reason-not-good-enough]{C-05} wurden Beispiele für bisherige Entscheidungsketten aufgeführt.
Diese Ketten sind lose in einem Kommentarblock strukturiert, über den eigentlichen Einträgen.
Jede Kette startet mit der Repräsentation, zu der es zu prüfen gilt, ob sie auf das aktuelle Artefakt anwendbar ist.
Die Elemente der Kette stellen je eine Referenz, ein Zitat, eine Begründung oder Ableitung dar, die im letzten Kettenelement verwendet werden, um ein Urteil über die Anwendbarkeit der Repräsentation zu fällen.
Der klare Vorteil dieses Schemas ist die Leichtigkeit, während der Forschungsarbeit über die Schlussfolgerungsketten die einzelnen Schritte in dem formlosen Kommentarfeld zu dokumentieren, da jede Art von Inhalt erlaubt ist.
Jedoch kann ein Kommentar in \acrshort{yaml} nicht ausgewertet werden, und die Formlosigkeit erlaubt es, auch \enquote{falsch} formatierte Ketten aufzubauen.

Das neue Format soll die Einfachheit und Erweiterbarkeit des alten Formats zu behalten, aber soll es so strukturieren, dass es Teil des Modells der Kanten sein kann.
Da das Subjekt der Begründung bereits durch die Kantenrichtung festgelegt ist, muss nur die Begründungskette und das Urteil aufgenommen werden, nicht der Startpunkt.
Daraus lässt sich ein neues Format ableiten:
Das Urteil wird in einem Attribut \enquote{why} als Text abgelegt und die Begründung für dieses als Liste an Texten in \enquote{because}.
Jeder Eintrag in dieser Liste entspricht einem der ursprünglichen Schritte in der Kette entspricht.
Diese Felder sind außer der Einordnung als Textfelder noch immer nicht weiter typisiert, um noch immer eine möglichst große Freiheit zu ermöglichen und zukünftige Begründungstechniken nicht einzuschränken.

\subsubsection{Produktreferenzen auf Knoten}

Auf einem Knoten wurden als relevante Metadaten die Produktbeschreibung und eine Menge an Referenzen auf Webseiten wie die Projekte, Homepages, Dokumentationen, \ldots identifiziert.
Diese werden als solche in das Datenmodell aufgenommen.
Die Beschreibung wird als ein einfaches Textfeld dargestellt, die Referenzen sind ein Objekt, bei dem die Schlüssel die Art der Referenz und der Wert die Referenz (Link) selbst ist.
Bisher festgelegte Referenztypen sind unter anderem \enquote{homepage}, \enquote{repository}, \enquote{documentation} und \enquote{api}.
Um jedoch die Erweiterbarkeit zu sichern, kann als Schlüssel jeder Wert verwendet werden.

\subsection{Datenmodell}

Um die in den vorhergegangenen Kapiteln konzeptionellen Elemente in einer formalen Struktur umsetzen zu können, wird im Folgenden ein einheitliches Datenmodell für die Graphentitäten definiert.

Jeder Knoten wird durch mindestens die folgenden Basisattribute definiert:

\begin{itemize}
    \itemsep0em
    \item \texttt{id}: Eindeutiger Bezeichner innerhalb des Knotentyps, abgeleitet aus der jeweiligen Repräsentationslogik (z.\,B. CPE-Parts oder PURL-Attribute).
    \item \texttt{node type}: Klassifizierung des Knotens entsprechend der unterstützten Ökosysteme (z.\,B. \texttt{cpe}, \texttt{purl}, \texttt{artifact}).
    Je nach Typ erhält ein Knoten weitere Attribute, in denen er weitere für ihn relevante Daten ablegen kann.
    \item \texttt{namespaces}: Menge an Namensraum-Labels zur Filterung von Transformationen.
    \item \texttt{metadata}: Dokumentationselemente mit Beschreibungen (\texttt{description}) und einer Menge an benannten externen Referenzen (\texttt{references}).
    \item \texttt{contributors}: Protokollierung der Datenquellen und Bearbeiter.
\end{itemize}

Kanten modellieren gerichtete Beziehungen zwischen Knoten mit:

\begin{itemize}
    \itemsep0em
    \item \texttt{source}/\texttt{target}: Referenzen auf die verbundenen Knoten (über deren \texttt{id}/\texttt{type}-Kombination).
    \item \texttt{type}: Beziehungskategorie (\enquote{is}/\enquote{is not}/\enquote{inherit}).
    \item \texttt{metadata}: Begründung der Existenz und Bedeutung eines Knotens mit einem Entschluss als Textfeld in \texttt{why} und einer Begründung in Form einer Text-Liste in \texttt{because}.
    \item \texttt{transform}: Filtermetriken für die Anwendbarkeit auf Start-/Zielknoten und eine Attributmenge, die vom Zielknoten typabhängig interpretiert werden soll.
\end{itemize}

Diese Elementeigenschaften werden bei der Implementierung die Grundlage für das effektive Datenmodell bilden.

\subsection{Graphmodifikation}\label{subsec:model-graph-modification}

Um es nach \hyperref[subsec:req-manual-format-modification]{A-10} zu ermöglichen, auf eine normalisierte Weise den Graphen von den automatisierten oder manuellen Prozessen zu modifizieren, ist ein allgemeines Schema nötig, das von allen gleichermaßen verwendet werden kann.
Das Modifikationsformat muss grundlegende Operationen auf dem Graphen erlauben: die Erstellung, Änderung und Entfernung von Knotenpunkten jeden Typs sowie die Erstellung, Änderung und Entfernung von Kanten zwischen diesen Knoten.

Das Subjekt einer Modifikation ist ein typisierter Knotenpunkt, von dem die Metadaten oder angrenzenden Kanten modifiziert werden können.
Da jeder Knotenpunkt mit der Kombination aus Typ und Id eindeutig ist, ist die Angabe eines Typs und einer Id in der Modifikation unerlässlich.
Da die einzelnen Knotentypen jeweils dedizierte Metadaten enthalten, muss auch die Modifikation über den Typ Zugriff auf diese dedizierten Attribute der Knoten erhalten.
Im vorherigen Format war es eine Herausforderung, ursprüngliche Einträge in den \acrshort{yaml}-Dateien aus dem Datenmodell heraus wiederzufinden (\hyperref[subsec:c-11-finding-yaml-entries]{C-11}).
Dies ist im neuen System eine einfache Aufgabe, da die Einträge jeweils ihren Typ und die Id angeben müssen, um das Subjekt der Modifikation zu identifizieren.

Bei der Selektion können zwei Szenarien auftreten: der Knoten existiert bereits, oder er tut es noch nicht.
Die Modifikationen operieren überschreibend oder erweiternd auf Knotenpunkten, sie fügen ihre Informationen zu diesen hinzu oder überschreiben vorhandene Attribute.
Für die einzelnen Attribute muss dementsprechend festgelegt werden, wie sie sich bei einer Erweiterung oder beim Überschreiben verhalten.
Falls ein Knotenpunkt dem Graphen noch nicht bekannt ist, kann er einfach durch die Kombination aus Typ und Id angelegt, und die Modifikation auf diesen neuen Knoten angewendet werden.
Da die automatisierten Generierungsprozesse in der Regel für ihre Modifikationen nicht daran interessiert sind, ob ein Knotenpunkt bereits existiert oder nicht, sondern einfach ihre Relationen oder Metadaten hinzufügen wollen, kann hier der vorherige Zustand ignoriert werden und die Modifikation auf den neuen oder bereits vorhandenen angewendet werden.

Für den Fall der manuellen Modifikation muss jedoch die Erwartungshaltung an den vorherigen Zustand in der Modifikation festgehalten werden.
Dies liegt daran, dass wenn bisher ein Knoten erzeugt werden musste, weil es ihn noch nicht gab, und er dann auf einmal durch eine Änderung der automatisierten Datenquellen doch bereits vorhanden ist, muss manuell geprüft werden, ob dies noch immer das erwartete Verhalten bewirkt.
Der umgekehrte Fall ist ebenso relevant, falls ein Knotenpunkt auf einmal aus einer Datenquelle verschwinden sollte, will man dies mitbekommen.

Zudem muss es die Möglichkeit geben, Informationen aus einem Knoten wieder zu entfernen.
Da dies in der Analysephase des Projekts immer gut durch das Überschreiben von Kantentypen oder Überschreiben von anderen Attributen gelöst werden konnte, wird hier der einfache Ansatz einer \enquote{reset}-Modifikation gewählt, der einen Knotenpunkt vollständig zurücksetzt und alle ein- und ausgehenden und Kanten entfernt.

Daraus ergeben sich die folgenden Modifikationsmodi:

\begin{itemize}
    \itemsep0em
    \item \enquote{create} geht davon aus, dass ein Knoten noch nicht existiert.
    Er wird den Modifikationsprozess zum Stoppen bringen, falls der Knoten bereits existierte, hat aber sonst keine weiteren Effekte.
    Der Erstellungsmodus ist der Standard-Modus, da dieser in Tests der am häufigsten verwendete war.
    \item \enquote{append} erwartet, dass der Knoten bereits existiert.
    Bei ihm wird der Prozess gestoppt, falls er noch nicht existiert.
    \item \enquote{reset} erwartet, dass der Knoten bereits existiert, und setzt all seine Attribute und Kanten zurück.
    Er stoppt den Prozess ebenfalls, falls der Knoten noch nicht existiert.
    \item \enquote{create\_or\_append} ignoriert den vorherigen Zustand.
    Dieser Modus wird nur den automatischen Prozessen exponiert, da die Erwartungshaltung im manuellen Format angegeben werden soll.
\end{itemize}

Der Kernpunkt ist, dass das Format alle als notwendig identifizierten Modifikationen am Graphen vollführen, und so in den automatischen Contributor-Prozessen und einem manuellen Format einheitlich mit allen Zusicherungen verwendet werden kann.

\subsection{\acrshort{yaml}-Format für Graphmodifikationen}\label{subsec:modell-graph-modification-yaml}

Um die Nutzerfreundlichkeit zu gewährleisten, wurde über einen iterativen Designprozess ein neues \acrshort{yaml}-basiertes Format entwickelt, mit dem Graphmodifikationen ausgedrückt werden können (\hyperref[subsec:req-manual-format-modification-for-real]{A-11}).
Das Format muss auf dem definierten Modifikationsformat aufbauen und sich darin abbilden lassen.
Eine Priorität des Formats war nicht nur die Lesbarkeit und Einfachheit das \acrshort{yaml} zu schreiben, sondern auch die Länge der einzelnen Einträge so kurz wie möglich zu halten.

Die oberste Ebene des \acrshort{yaml}-Dokuments ist eine Liste, in der jeder Eintrag eine Modifikation an einem Knoten, und damit in den meisten Fällen einen Knoten im Graphen darstellt.
Um die Identifikation eines Knotens so kurz und einfach wie möglich zu gestalten, wird Knotentyp (z.\,B. \texttt{cpe}, \texttt{product}, \texttt{artifact}) als Top-Level-Schlüssel verwendet, dessen Wert die eindeutige Id des Knotens enthält.
Dies aggregiert zwei Attribute in eines und spart damit Zeilen und kann dennoch problemlos erkannt werden, da alle Knotentyp-Bezeichner bekannt sind.
Zudem wird dieses Muster (\enquote{type: id}) immer wieder im Format verwendet und schafft damit eine einheitliche Weise, wie Knoten selektiert werden.
Da im Moment keine der geplanten Knotentypen, neben Produkt- und Artefakt-Knoten, weitere komplexen identifizierenden Attribute besitzen, wurde diese Adressierungslogik noch weiter vereinfacht, sodass direkt eine Repräsentation des gegebenen Typs angegeben werden kann und daraus nach den Regeln aus \autoref{subsubsec:model-graph-knoten} eine Id erzeugt wird.
Beispielsweise wird ein \texttt{artefact}-Knoten durch \texttt{artifact: "npm @material / banner"} adressiert, oder ein Knoten vom Typ \texttt{cpe} durch \texttt{cpe: "cpe:/a:redis:redis"} angegeben, woraus implizit die Id \texttt{a:redis:redis} abgeleitet wird.

An Knoten können mit \texttt{metadata} diverse Metadaten angefügt werden (\hyperref[subsec:req-reason-format]{A-12}).
Das \texttt{metadata}-Feld ermöglicht es Beschreibungen (\texttt{description}) und externe Referenzen (\texttt{references}) unter beliebigen Keywords wie \texttt{homepage} abzulegen.

Typspezifisch sind momentan nur für Produkt- und Artefakt-Knoten weitere Attribute geplant.
Bei Artefakten ist das \texttt{identification}-Attribut, welches eine Liste von Selektoren mit den Kriterien für das Matching von eingehenden Artefakten enthält.
Nach \hyperref[subsec:req-type-specific-matching]{A-06} ermöglicht es die Verwendung von normalisierten Ökosystembezeichnern (\texttt{type}, z.\,B. \texttt{python}, \texttt{npm}) und typspezifischen Attributen (\texttt{name}, \texttt{scope}, \texttt{packageName}), die über spezielle Extraktoren ermittelt werden.
Wildcard-Selektoren können noch immer im alten Format inkrementell aktiviert werden (\hyperref[subsec:req-regex-support]{A-09}).
Um mehrere Werte pro Attribut angeben zu können (\hyperref[subsec:req-multiple-attribute-values]{A-08}), können statt wie bisher nur Text-Werte auf den Attributen auch \acrshort{yaml}-Listen angegeben werden, deren Elemente durch eine logische ODER-Verknüpfung verbunden werden (z.\,B. \texttt{name: ["web3-react\_walletconnect", "walletconnect", "@web3-react/walletconnect"]}).

Kantenbeziehungen werden innerhalb der Knotendefinitionen unter den festgelegten Schlüsseln \texttt{is}, \texttt{is not} und \texttt{inherit}.
Die Attribute enthalten je eine Liste von Zielknotenselektoren, zu denen die Beziehung aufgebaut werden soll, deren Format ebenfalls das \enquote{type: id}-Schema verwenden.
Auf dem gleichen Objekt werden zudem die Metadaten der Kante aufgeführt, die sie haben soll.
Diese sind einmal die Begründungsfelder \texttt{why} mit der aus der Nachforschung abgeleiteten Entscheidung als Textattribut aufgenommen werden kann und \texttt{because}, in der die Begründung schrittweise als Text-Liste steht.

Neben diesen Metadaten gibt es auf Kanten die \texttt{transform}-Anweisung, in der eine Liste an Transformationen an einen Zielknoten definiert, um dessen Bedeutung zu verändern.
Neben den Transformationsattributen nimmt jeder Eintrag optional eine Anwendbarkeitsbedingung in dem Attribut \texttt{for} aufgeführt werden, die den Zielknoten auf einen Typen, die Id und weitere Attribute filtern kann.
Auf Produkt-Knoten geschieht die Definition von Transformationen in dem \texttt{namespaces}-Attribut, welcher ein Objekt darstellt.
Jeder Schlüssel in diesem Objekt stellt den Bezeichner eines Namespaces dar, den sowohl Quell- als auch Zielknoten besitzen müssen, um überhaupt in Frage zu kommen.
In den Objekt-Werten sind über das \texttt{source}-Attribut weitere Filter auf den Quellknoten möglich, in \texttt{target} werden die anzuwendenden Transformationen aufgelistet.

Die Begründungsfelder sind genau wie in \autoref{subsec:model-rationale} erklärt auf den Knoten und Kanten als Objekte und Listen verfügbar.

Ein einfaches Beispiel für die Definition von drei Knoten und zwei Kanten kann in \autoref{lst:modell-graph-modification-yaml-demo} im \acrshort{yaml}-Format eingesehen werden, wie sich die Auswertung davon im Graphen darstellt ist in \autoref{fig:modell-graph-modification-yaml-demo-rendered} abgebildet.
Um die Fähigkeiten des Formats als \textit{Modifikations}format zu demonstrieren wird auf dem vorherigen Graphen mit einer weiteren Modifikation in \autoref{lst:modell-graph-modification-yaml-demo-append} aufgebaut, woraus sich der Graph in \autoref{fig:modell-graph-modification-yaml-demo-append-rendered} ergibt.
Weitere Beispiele und die Referenzfälle können in \autoref{sec:beispiele-fertige-implementierung} gefunden werden.

\begin{lstlisting}[style=yaml,caption={Beispiel des \acrshort{yaml}-Modifikationsformats (create mode)},label={lst:modell-graph-modification-yaml-demo},basicstyle=\ttfamily\scriptsize]
- cpe: "cpe:/a:ellucian:banner"
  metadata:
    description: "Student information system"
    references:
      homepage: https://www.ellucian.com

- artifact: "npm @material / banner"
  identification:
    - type: npm
      scope: "@material"
      packageName: "banner"
  is:
    - product: "NPM Material Design Banner Component"

- product: "NPM Material Design Banner Component"
  is not:
    - cpe: "a:ellucian:banner"
      why: "Refers to an Enterprise SIS system"
      because:
        - "Ellucian Banner is student information software"
        - "No relation to web components"
\end{lstlisting}

\begin{figure}[htbp]
    \centering
    \makebox[\textwidth]{\includesvg[width=1.3\textwidth, inkscapelatex=false]{bilder/example-graph-material-banner}}
    \caption{Generierter Graph aus dem Beispiel des \acrshort{yaml}-Modifikationsformats (create mode)}
    \label{fig:modell-graph-modification-yaml-demo-rendered}
\end{figure}

\begin{lstlisting}[style=yaml,caption={Beispiel des \acrshort{yaml}-Modifikationsformats (append mode)},label={lst:modell-graph-modification-yaml-demo-append},basicstyle=\ttfamily\scriptsize]
- cpe: "cpe:/a:blogstand_banner_plugin_project:blogstand-smart-banner"

- product: "NPM Material Design Banner Component"
  mode: append
  is not:
    - cpe: "a:blogstand_banner_plugin_project:blogstand-smart-banner"
      why: "Not a Material Design component, is an abandoned WordPress plugin"
      because:
        - "affected by CVE-2014-4848"
        - "http://packetstormsecurity.com/files/127290/WordPress-Blogstand-Smart-Banner-1.0-Cross-Site-Scripting.html"
        - "http://wordpress.org/plugins/blogstand-smart-banner"
        - "This plugin has been closed"
        - "Only one version released 12 years ago"
\end{lstlisting}

\begin{figure}[htbp]
    \centering
    \makebox[\textwidth]{\includesvg[width=1.3\textwidth, inkscapelatex=false]{bilder/example-graph-material-banner-append}}
    \caption{Generierter Graph aus dem Beispiel des \acrshort{yaml}-Modifikationsformats (append mode)}
    \label{fig:modell-graph-modification-yaml-demo-append-rendered}
\end{figure}

\subsection{Auswertung des Graphen anhand eines Artefakts}\label{subsec:model-apply-to-artifact}

Der Fokus dieser Arbeit liegt darauf, den Produktgraphen für das neue Korrelationssystem vorzubereiten.
Da in diesem Kontext die Traversierungsrichtung immer von Artefakt-Knoten zu anderen Repräsentationen ausgeht, wird zunächst der Fokus nur auf den Abgleich von Knoten des Typs \texttt{artefact} mit Artefakten gelegt.
Die hier aufgeführten Regeln lassen sich daraus jedoch auch recht einfach für weitere Knotentypen ableiten.

Das Anwenden von Informationen aus dem Graphen auf ein Referenzartefakt erfolgt in vier getrennten Schritten, die jeweils eine definierte Ausgabe bereitstellen.

\begin{enumerate}
    \itemsep0em
    \item Artefakt-Typ-Erkennung: Typspezifische Attribute werden aus dem Artefakt abgeleitet, die in der Selektion ausgewertet werden können.
    \item Knoten-Identifikation: Die Selektoren der Artefakt-Knoten im Graphen werden ausgewertet, um zutreffende Artefakt-Knoten zu finden.
    \item Graph-Traversierung: Von den identifizierten Knoten aus werden erreichbare Repräsentationen ermittelt und Metadaten auf dem Weg dorthin aggregiert.
    \item Anwendung: Gefundene Knoten wenden ihre typspezifische Logik auf das ursprüngliche Artefakt an, um es zu transformieren.
\end{enumerate}

Diese Schritte werden in den folgenden Unterkapiteln detailliert.

\subsubsection{Matching von Artefakt-Repräsentationen}\label{subsubsec:model-matching}

Eine der Qualitätsanforderungen an den Graphen (\hyperref[subsec:req-graph-inner-consistency]{A-19}) ist, dass genaue eine Repräsentation im Graphen mit einer Eingabe übereinstimmt.
Das bedeutet auch, dass bei der Abfrage eines Artefakts nur ein einiger Knoten gefunden werden darf, der diesem entspricht.
Es werden dafür im Folgenden zwar Mechanismen bereitgestellt, die dieses Verhalten möglichst einfach für einen Anwender nutzbar machen, jedoch kann die explizite manuelle Modellierung eines solchen Falles nicht von der Konzeption her ausgeschlossen werden.
Daher ist es so wichtig, einen sich selbst pflegenden Testdatensatz zu führen, der die Identifikationen regelmäßig automatisch prüft.

In den nächsten Kapiteln wird wird zunächst die Artefakt-Selektion auf einzelnen Knoten eingeführt, dann werden mehrere Knoten über Vererbungsregeln kombiniert und deren Regeln erläutert.

\paragraph{Artefakt-Typ-Erkennung}

Vor der Auswertung des Graphen wird das zu identifizierende Artefakt mit den Mustern aus \autoref{subsec:erkennung-typspezifische-artefakte} abgeglichen, um typspezifische Informationen für den Abgleich der Artefakt-Selektoren der Knoten zu erhalten.
Diese programmatisch ermittelten Attribute sichern, dass Attributwertprüfungen schärfer, zuverlässiger und atomarer durchgeführt werden können.

\paragraph{Artefakt-Selektor}

Jeder Artefakt-Knoten enthält eine Liste an Selektoren, die durch ein logisches ODER verbunden werden, damit nur ein Selektor zutreffen muss, um ein Artefakt zu identifizieren.
Das ermöglicht es, mehrere Alternativen aufzuführen, wie sich ein reales Artefakt in seiner Attributmenge ausprägen kann und verhindert die Notwendigkeit, einen zweiten Knoten für dasselbe Artefakt anlegen zu müssen.

Jeder Selektor besteht aus einer Menge an Attributen, von denen alle für ein Artefakt mit einem logischen UND übereinstimmen müssen, um den Eintrag zu aktivieren.
Um \hyperref[subsec:req-multiple-attribute-values]{A-08} zu erfüllen, sind die Werte der abzugleichenden Attribute als Listen an möglichen Werten abgelegt, die mit einem weiteren logischen ODER verbunden sind, also von denen nur ein Wert zutreffen muss.
Zudem können die Werte nach \hyperref[subsec:req-regex-support]{A-09} das bisherige inkrementelle Wildcard-System verwenden, um möglichst alle Matching-Fälle abzudecken.
Die abfragbaren Attribute sind in zwei Mengen geteilt, die sich in ihrer Quellen unterscheiden.

Rohe Artefakt-Attribute beziehen sich auf die Attribute, die das Artefakt direkt in sich speichert.
Im alten System war diese Menge die einzige, die abgefragt werden konnte.
Häufig verwendete Attribute sind \texttt{Id}, \texttt{Type} und Ökosystemspezifische wie \texttt{Group Id}.
Da diese Art von Abfrage in dem neuen Format aufgrund ihrer Instabilität, der Unschärfe wegen der Kombination von mehreren Werten in einem Attribut und der anderen Herausforderungen auf Artefakt-Attributen in den Hintergrund treten soll, werden diese Abfragen explizit als solche gekennzeichnet werden müssen.

Die neuen typspezifischen Attribute werden von den in \autoref{subsubsec:model-graph-knoten} aufgelisteten Extraktoren aufbereitet und in den Selektoren als primäre, auf der obersten Ebene bereitgestellten Attribute zur Verfügung gestellt.
Die Standard-Attribute sind \texttt{type} zur Auswahl eines erkannten Artefakttyps, \texttt{name} für einen ökosystemspezifischen Paketnamen und \texttt{version} für die Version.
Basierend auf dem \texttt{type}-Wert wird in dem Objekt die Präsenz weiterer Attribute der typisierten Artefakte zugesichert und für Abgleiche exponiert.

\paragraph{Vererbung von Selektoren}

Wie in \autoref{subsubsec:model-edges-relations} erwähnt haben Artefakt-Knoten die Möglichkeit, sich mit einer Vererbungskante auf weitere Artefakt-Knoten zu beziehen.
Eine solche Beziehung bedeutet, dass der Knoten, von dem geerbt wird, ebenfalls mit seinen Selektoren auf das aktuell zu prüfende Artefakt erfolgreich übereinstimmen muss.
Diese Beziehung kann verkettet werden, indem von dem geerbten Knoten eine weitere Vererbungskante startet.
Auf diese Weise können beliebig viele Identifikationen aufeinander folgen.

Dies führt zu einer weiteren Herausforderung in der Identifikationslogik, da nach \hyperref[subsec:req-graph-inner-consistency]{A-19} immer nur genau ein Knotenpunkt für eine zu identifizierende Repräsentation gefunden werden darf.
Da die allgemeineren Knotenpunkte, von denen die spezifischen Ausprägungen der Artefakt-Knoten erben, bei einem Artefakt welche den spezifischen Knoten selektieren immer auch mit den Selektoren des allgemeinen Knotens übereinstimmen werden, muss eine Ausschlusslogik implementiert werden.
Da immer die spezifischste Identifikation für die Repräsentation gewählt werden soll, wird auf der Ergebnismenge der gefundenen Knoten die Hierarchie der Vererbung ausgewertet und alle entfernt, von denen geerbt wird.

\paragraph{Ergebnisse der Selektion}

Das Ergebnis des Selektionsprozesses ist im optimalen Fall ein einziger \texttt{artifact}-Knoten im Graphen, dem das eingehende Software-Artefakt entspricht.
Es lässt sich jedoch aufgrund eines ungünstig strukturierten Graphen nicht ausschließen, dass doch eine Menge an Knoten identifiziert wird.
Da der restliche Ablauf des Prozesses den Graphen auf ein Artefakt anzuwenden jedoch pro Knotenpunkt getrennt durchgeführt wird, macht dies für die restliche Beschreibung keinen Unterschied.
Dieser (bzw.\ diese) gefundene(n) Knoten dienen als Ausgangspunkt für die anschließende Durchquerung des Graphen (\autoref{subsubsec:model-traversal}), um die zugehörigen Repräsentationen zu ermitteln.

\subsubsection{Durchquerung des Graphen}\label{subsubsec:model-traversal}
% Auswertungslogik für Relationen und Versionstransformation

Nachdem ein eingehendes Artefakt erfolgreich einem \texttt{artifact}-Knoten im Graphen zugeordnet wurde, beginnt die Phase der Graphen-Durchquerung.
In der Traversierung des Graphen von dem Startknoten zu den Zielknoten werden entlang der Kanten und Knoten zugehörige Metainformationen aggregiert, die dann in der anschließenden Auswertungsphase interpretiert werden.
In diesem Prozess werden Kanten der Repräsentationsbeziehungen \enquote{is} und \enquote{is not} unterschiedlich behandelt als die Vererbungsbeziehungen vom Typ \enquote{inherit}.

Der erste Pfad folgt allgemein den Repräsentationsbeziehungen, die zunächst vom Artefakt-Knoten und später von allen weiteren erreichbaren Knoten ausgehen.
Diesen Beziehungen wird allgemein immer gefolgt, egal ob es eine positive oder negative Relation ist.
Falls es sich jedoch um eine negative Relation handelt, werden alle auf diesem Pfad durch den Graphen nachfolgenden Kanten ebenfalls als \enquote{is not} behandelt, was den späteren Anwendungsschritt beeinflusst.
Jede Kante stellt zudem optional Transformationsregeln bereit, die bei der Traversierung je durchquertem Pfad zunächst einmal einfach alle eingesammelt werden.
Erreichte Produktknoten enthalten ebenfalls optional Transformationsregeln, die nur dann mit in die Liste an Transformationen eingesammelt werden, wenn der ursprüngliche Quellknoten teil des Namensraums ist, unter dem diese Transformation abgelegt ist.
Die konkrete Anwendbarkeit basierend auf Quell- und Zielknoteneigenschaften wird erst im nächsten Schritt ausgewertet, wenn die Zielknoten alle gesammelt wurden.

Der zweite Pfad wertet Vererbungshierarchien zwischen Knoten aus.
Vererbungshierarchien bei Artefakt-Knoten werden ausschließlich zum Teilen der Selektoren in dem initialen Identifikationsprozess verwendet.
Daher werden hier ausschließlich die Vererbungskanten zwischen Produkt-Knoten ausgewertet.
Allgemein funktioniert das Folgen der Vererbungskanten identisch, wie die regulären Repräsentationsbeziehungen, mit dem Unterschied, dass nur die spezifischsten Kanten auf einen zwischen Vererbungsebenen geteilten Knoten behalten werden.
Dies wird dadurch ermöglicht, indem zunächst über die Auswertung der allgemeinen Knoten die allgemeineren Kanten zum Erreichen eines Knotens gespeichert werden und die spezialisierten Knoten später diese Kanten mit ihren eigenen überschreiben werden.

Während der rekursiven Durchquerung sollte das System einen Kontextzustand mit Informationen über den aktuellen Pfad durch den Graphen verwalten.
Die Informationen, die der Pfad verwaltet, sind der aktuellen Knoten, die Beziehung die zum Erreichen dieses verwendet wurde, der gesamte bisherige Pfad zur Vermeidung von Schleifen, und die gesammelten Transformationsanweisungen.

Die Gesamtheit der gesammelten Kontextzustände ist das Ergebnis dieser Phase und die Eingabe für die finale Anwendung der Zielknoten.
Jeder Kontext stellt dabei einen Zielknoten dar, mit dem vollständigen Pfad der Entscheidungsfindung und den Transformationen.

\subsubsection{Anwendung von zutreffenden Knotenpunkten auf Artefakte}\label{subsubsec:model-result-processing-apply-nodes-to-artifact}

Die identifizierten Zielknoten werden abschließend einzeln auf das Artefakt angewendet.
Dabei werden je Knoten zudem die erreichende Kante und die gesammelten Transformationen entlang des Pfades übergeben.

Zunächst werden die gesammelten Transformationen auf ihre Anwendbarkeit gefiltert.
Der Namensraum-Filter wurde bereits während dem letzten Schritt der Traversierung berücksichtigt, sodass nun die Quellartefakt- und Zielknotenfilter aus \autoref{subsubsec:model-graph-knoten} angewendet werden.
Die erste Prüfung ist die Existenz einer Transformation mit dem \texttt{discard}-Attribut, hier wird der Knoten vollständig von der Identifikation verworfen.
Ein weiteres Transformationsattribut kann den Typ der eingehenden Kante auf einen anderen (z.\,B. \enquote{is not}) überschreiben.

Die verbleibenden Transformationen modifizieren die Knotendaten mit typspezifischen Attributen.
Die restlichen Transformationsattribute werden an den Zielknoten übergeben, um typspezifische Änderungen an den anzuwendenden Daten vorzunehmen, bevor sie auf das Artefakt angewendet werden.
So wird beispielsweise bei \acrshort{cpe}-Repräsentationen die \acrshort{cpe} in ihre Komponenten zerlegt, die dann durch Transformationen auf konkrete Werte gesetzt werden können (z.\,B. \texttt{vendor} oder \texttt{version}).
Die modifizierten Komponenten werden dann wieder zu einer gültigen \acrshort{cpe} kombiniert.
Andere Repräsentationstypen folgen ähnlichen Mustern mit eigenen typspezifischen Attributen.

Die transformierten Knoten werden abschließend unter Berücksichtigung des effektiven Kantentyps auf das Subjekt, dem Artefakt, angewandt.
Bei \acrshort{cpe}-Knoten führt eine \enquote{is}-Beziehung zum Hinzufügen der \acrshort{cpe} zu \texttt{Additional CPE URIs} und dem Entfernen aus \texttt{Inapplicable CPE URIs}, wobei \enquote{is not} entsprechend das umgekehrte bewirkt.
Dies verhindert implizit Widersprüche durch gegensätzliche Klassifizierungen einer \acrshort{cpe} und löst eine der Herausforderungen von \hyperref[subsec:c-10-order-dependency]{C-10}.
