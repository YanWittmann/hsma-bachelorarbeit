\section{Modell des neuen Korrelationssystems}\label{sec:model-modellierungsansatz}

Aufgrund der abgeleiteten Anforderungen und den Referenzfällen wird in den folgenden Unterkapiteln das neue Korrelationssystem mit der Struktur des Graphen, einem Modifikationsformat um den Graphen zu transformieren, dem \acrshort{yaml}-Format um die Modifikationen manuell durchführen zu können, und die Matching- und Durchquerungsregeln für die Auswertung von Repräsentationsauflösungen.

\subsection{Struktur des Graphen}\label{subsec:model-graph-struktur}

Wie in \hyperref[subsec:req-format-product-graph]{A-01} und \hyperref[subsec:req-product-concept]{A-02} gefordert, wird das neue Korrelationssystem mithilfe eines Graphens modelliert, in dem jeder Knotenpunkt entweder einem Produkt oder einer Repräsentation eines Produktes entspricht und durch Kanten verbunden sind, die die Beziehungen zwischen diesen modellieren.

\subsubsection{Knotenpunkte}\label{subsubsec:model-graph-knoten}

Betrachtet werden zunächst die Knotenpunkte der Repräsentationen von Produkten.
Für jedes Produktidentifikationsstandard-Ökosystem wird ein Typ für einen Knotenpunkt angelegt, der dem Knoten typspezifische Attribute und Eigenschaften zuweisen kann.
Diese definieren, wie sich ein Knoten selbst identifiziert und kann zum Abgleich von zugehörigen Repräsentationen mit sich selbst verwendet werden, um herauszufinden, ob eine reale Repräsentation einem Knotenpunkt entspricht.
Zudem kann diese Knoteninformation in Kombination mit dem Typen einer eingehenden Kante interpretiert werden, um eine Transformation an dem Ursprungsknotenpunkt anzuwenden.

Um jeden Knoten eindeutig ansprechen zu können und um die Eindeutigkeit eines Knotens zu sichern hat jeder Knoten im Datenmodell neben seinem Typen zusätzlich eine eindeutige Id.
Die Kombination aus Typ und Id ermöglicht eine genaue Identifikation.
Die Anforderung, dass sich jede Repräsentation eines Produkts in nur einem Knoten ausprägen darf, löst die Reihenfolgenabhängigkeit (\hyperref[subsec:c-10-order-dependency]{C-10}), da jede Identifikation nur einmal vorkommen kann und die weiteren Abhängigkeiten über weitere Kanten dargestellt werden.

Allgemein soll jeder Knoten, und jede Kante, in der Lage sein, Metadaten über sich selbst abzulegen.
Mehr Details dazu kann in \autoref{subsec:model-rationale} gefunden werden.

Die genauen Ausprägungen der initial geplanten Knotentypen und deren Attribute und Verhalten können im Folgenden betrachtet werden.
Der Produkt-Knotenpunkt wird in \autoref{subsubsec:model-product-node} detailliert beschrieben.
Um von Anfang an ein einheitliches Format für die Ids unterschiedlicher Typen zu sichern, wird zudem auch eine Regel angegeben, wie aus einer Repräsentation die entsprechende Id abgeleitet werden kann.

\begin{itemize}
    \itemsep0em
    \item \textit{\acrshort{cpe}}: repräsentieren genau eine \acrshort{cpe} mit einer Menge an gesetzten Parts, beispielsweise \texttt{cpe:/a:redis:redis}.
    Wenn ein solcher Knoten über eine \enquote{is}-Beziehung von einem Artefakt aus erreicht wird, wird die entsprechende \acrshort{cpe} dem Ziel-Artefakt als \texttt{Additional CPE URIs} hinzugefügt, und von \texttt{Inapplicable CPE URIs} entfernt.
    Bei \enquote{is not} passiert entsprechend das Gegenteil.
    Die Id eines \acrshort{cpe}-Knotens leitet sich aus der Menge an Doppelpunkt-getrennten Parts ab, die in der \acrshort{cpe} gesetzt sind, wobei Lücken zwischen gesetzten Parts immer mit \enquote{*} aufgefüllt werden müssen.
    Zu der redis-\acrshort{cpe} wäre die Id entsprechend: \texttt{a:redis:redis}.
    \item \textit{\acrshort{purl}}: verhält sich ähnlich wie ein \acrshort{cpe}-Knoten, es werden beliebige Attribute einer \acrshort{purl} abgelegt, auf die ein Artefakt geprüft werden kann.
    Bei \acrshortpl{purl} wird die Knoten-Id wie die \acrshort{purl} selbst, nur ohne den \texttt{pkg:}-Präfix geschrieben.
    \item \textit{MS Product ID}: stellen eine numerische Produkt-Id dar, und können optional anzuwendende KB-Nummern (Security-Patch Ids) enthalten.
    Ähnlich wie bei dem \acrshort{cpe}-Knoten werden Artefakten bei positiver oder negativer Übereinstimmung die Ids in dem Attribut \texttt{MS Product Id} hinzugefügt oder entfernt.
    Die Knoten-Id ist identisch mit der Produkt-Id.
    \item \textit{\acrshort{eol}-Id}: enthält genau eine Produkt-Id aus dem endoflife.date-Ökosystem und optional eine Referenz auf einen Zyklus innerhalb dieses Produkts.
    Die Knoten-Id ist identisch mit der Produkt-Id.
    \item \textit{Artefakt}: repräsentieren tatsächliche Software-Artefakte, die in einem Inventar aus einem Software-Scan oder einer \acrshort{sbom} gefunden werden können.
    In dem Nutzungskontext der Korrelationsdaten dienen sie als Ausgangspunkt für den Selektionsprozess und die anschließende Graphen-Durchquerung um Effekte auf ein Artefakt zu bestimmen.
    Ein Artefakt-Knoten besitzt einen Selektionsblock, der die Kriterien für die Artefakt-Selektion enthält.
    Die Selektionslogik wird in \autoref{subsec:model-matching} genauer ausgeführt.
\end{itemize}

\subsubsection{Produkt-Knoten}\label{subsubsec:model-product-node}
Produkt-Knoten sind eine spezielle Form von Knoten, die ein Software-Produkt wie in \autoref{subsec:produkte-vs-reprasentation} detailliert darstellen.
Sie enthalten im Gegensatz zu den konkreten Repräsentationsknoten keine Selektoren oder Informationen darüber, wie eine Repräsentation modifiziert werden soll, sondern dient als logische Klammer und zentraler Knoten für alle Repräsentationen, mit denen ein Produkt identifiziert werden kann.
So sollen Repräsentationen nicht direkt miteinander über Kanten verbunden werden, sondern einen Zwischenknoten definieren, der sie und potenziell weitere verbindet.

Um zu vermeiden, dass ähnlich wie im alten Korrelationssystem potenziell viele versionierte Ausprägungen einer gleichen Repräsentation als Knotenpunkte erstellt werden müssen, um versionierte \acrshortpl{cpe} zuordnen zu können, müssen Produkt-Knoten in der Lage sein, neben den normalen Begründungen und Referenzen auch weitere Metainformationen über die zugehörigen Repräsentationen abzulegen, vor allem Informationen über Versionsräume und wie zwischen diesen umgewandelt werden kann.
Diese Ansammlung an Metadaten und die Kanten zu Produktrepräsentation soll zu einem einheitlich aggregierten Produktkonzept führen.

\subsubsection{Kanten und Relationen}\label{subsubsec:model-edges-relations}
Die Kanten des Graphen sind gerichtete Beziehungen zwischen den Knotenpunkten und modellieren die logischen Verknüpfungen innerhalb des Korrelationssystems.
Die zwei primären Kantentypen sind \enquote{is} und \enquote{is not}.
Die Interpretation dieser Beziehungen liegt bei den Zielknoten, jedoch gilt allgemein das Folgende:

Die \enquote{is}-Kante (auch \enquote{is represented by}) drückt eine Zugehörigkeitsbeziehung aus.
Allgemein beschreibt sie, dass eine bestimmte Repräsentation die Ausgangsrepräsentation vollständig in einem anderen Ökosystem darstellt und für Anfragen in diesem verwendet werden kann.
Die \enquote{is not}-Kante (auch \enquote{is not represented by}) ist für einen expliziten Ausschluss der Anwendbarkeit einer Repräsentation auf einer Ausgangsrepräsentation zuständig und so Fehlidentifikationen explizit zu vermeiden.
So wird beispielsweise die positiv anwendbare Verknüpfung von Artefakt-Knoten mit Produkt-Knoten, und von Produkt-Knoten mit verschiedenen Standard-Identifikatoren (\acrshortpl{cpe}, \acrshortpl{purl} etc.) über \enquote{is}-Kanten realisiert, oder wenn ein Artefakt mit einem bestimmten Namen fälschlicherweise einer Produktfamilie zugeordnet werden könnte, kann eine \enquote{is not}-Kante die korrekte Trennung sicherstellen.

Beim Durchqueren des Graphen sind diese beiden Kantentypen jedoch nicht äquivalent auszuwerten, wie genauer in \autoref{subsec:model-traversal} beschrieben wird.
So überschreibt eine einzige Kante vom Typ \enquote{is not} bei allen direkt und indirekt darüber erreichbaren Knotenpunkten den Kantentyp ebenfalls auf \enquote{is not}.
Dies ist nötig, da es nicht korrekt wäre, eine Repräsentation als Anwendbar zu klassifizieren, nur weil die direkte Kante von der vorherigen Repräsentation sie als auf sich Anwendbar sieht.
Die Nicht-Anwendbarkeit wird also durch den Graphen propagiert.

Darüber hinaus existiert eine dritte Art von Kante, die eine Vererbung von Informationen repräsentiert (inheritance, \hyperref[subsec:req-selektor-inheritance]{A-04}).
Über diese sollen Basis-Eigenschaften von einem Eltern-Knoten an einen Kind-Knoten weitergegeben werden, mit dem Ziel, die Redundanz im Datenmodell zu reduzieren und die Pflege zu vereinfachen.
Im Stand dieser Arbeit sind zwei Anwendungsfälle für diese vorgesehen.
Mit der Verwendung dieses Kantentyps zwischen Artefakt-Knotenpunkten müssen zum erfolgreichen Matching eines Knotens auch alle darüberliegenden Knotenpunkte erkannt werden.
Bei der Auswahl der übereinstimmenden Artefakt-Knoten wird nur der spezifischste ausgewählt.
Der zweite Nutzungsfall sind Produkt-Knotenpunkte, bei denen auch alle geerbten Kanten zu anderen Knotenpunkten ausgewertet werden.
Eine Prüfung auf zirkuläre Vererbungs-Referenzen ist dabei nötig, um Schleifen zu verhindern und eine eindeutige Auflösung zu garantieren (\hyperref[subsec:req-graph-inner-consistency]{A-10}).

Falls es nötig ist, eine bidirektionale Beziehung darzustellen, kann mit einer identische, umgekehrten Kante die Richtung auf beide Seiten erweitert werden.

\subsection{Beschreibungen und Begründungen}\label{subsec:model-rationale}

\subsection{Graphmodifikation}\label{subsec:model-graph-modification}

Um es nach \hyperref[subsec:req-manual-format-modification]{A-07} zu ermöglichen, auf eine normalisierte Weise den Graphen von den automatisierten oder manuellen Prozessen zu modifizieren, ist ein allgemeines Schema nötig, das von allen gleichermaßen verwendet werden kann.
Das Modifikationsformat muss grundlegende Operationen auf dem Graphen erlauben: die Erstellung, Änderung und Entfernung von Knotenpunkten jeden Typs sowie die Erstellung, Änderung und Entfernung von Kanten zwischen diesen Knoten.

Das Subjekt einer Modifikation ist ein typisierter Knotenpunkt, von dem die Metadaten oder angrenzenden Kanten modifiziert werden können.
Da jeder Knotenpunkt mit der Kombination aus Typ und Id eindeutig ist, ist die Angabe eines Typs und einer Id in der Modifikation unerlässlich.
Da die einzelnen Knotentypen jeweils dedizierte Metadaten enthalten, muss auch die Modifikation über den Typ Zugriff auf diese dedizierten Attribute der Knoten erhalten.
Im vorherigen Format war es eine Herausforderung, ursprüngliche Einträge in den \acrshort{yaml}-Dateien aus dem Datenmodell heraus wiederzufinden (\hyperref[subsec:c-11-finding-yaml-entries]{C-11}).
Dies ist im neuen System eine einfache Aufgabe, da die Einträge jeweils ihren Typ und die Id angeben müssen, um das Subjekt der Modifikation zu identifizieren.

Bei der Selektion können zwei Szenarien auftreten: der Knoten existiert bereits, oder er tut es noch nicht.
Die Modifikationen operieren überschreibend oder erweiternd auf Knotenpunkten, sie fügen ihre Informationen zu diesen hinzu oder überschreiben vorhandene Attribute.
Für die einzelnen Attribute muss dementsprechend festgelegt werden, wie sie sich bei einer Erweiterung oder beim Überschreiben verhalten.
Falls ein Knotenpunkt dem Graphen noch nicht bekannt ist, kann er einfach durch die Kombination aus Typ und Id angelegt, und die Modifikation auf diesen neuen Knoten angewendet werden.
Da die automatisierten Generierungsprozesse in der Regel für ihre Modifikationen nicht daran interessiert sind, ob ein Knotenpunkt bereits existiert oder nicht, sondern einfach ihre Relationen oder Metadaten hinzufügen wollen, kann hier der vorherige Zustand ignoriert werden und die Modifikation auf den neuen oder bereits vorhandenen angewendet werden.

Für den Fall der manuellen Modifikation muss jedoch die Erwartungshaltung an den vorherigen Zustand in der Modifikation festgehalten werden.
Dies liegt daran, dass wenn bisher ein Knoten erzeugt werden musste, weil es ihn noch nicht gab, und er dann auf einmal durch eine Änderung der automatisierten Datenquellen doch bereits vorhanden ist, muss manuell geprüft werden, ob dies noch immer das erwartete Verhalten bewirkt.
Der umgekehrte Fall ist ebenso relevant, falls ein Knotenpunkt auf einmal aus einer Datenquelle verschwinden sollte, will man dies mitbekommen.

Zudem muss es die Möglichkeit geben, Informationen aus einem Knoten wieder zu entfernen.
Da dies in der Analysephase des Projekts immer gut durch das Überschreiben von Kantentypen oder Überschreiben von anderen Attributen gelöst werden konnte, wird hier der einfache Ansatz einer \enquote{reset}-Modifikation gewählt, der einen Knotenpunkt vollständig zurücksetzt und alle ein- und ausgehenden und Kanten entfernt.

Daraus ergeben sich die folgenden Modifikationsmodi:

\begin{itemize}
    \itemsep0em
    \item \enquote{create} geht davon aus, dass ein Knoten noch nicht existiert.
    Er wird den Modifikationsprozess zum Stoppen bringen, falls der Knoten bereits existierte, hat aber sonst keine weiteren Effekte.
    Der Erstellungsmodus ist der Standard-Modus, da dieser in Tests der am häufigsten verwendete war.
    \item \enquote{append} erwartet, dass der Knoten bereits existiert.
    Bei ihm wird der Prozess gestoppt, falls er noch nicht existiert.
    \item \enquote{reset} erwartet, dass der Knoten bereits existiert, und setzt all seine Attribute und Kanten zurück.
    Er stoppt den Prozess ebenfalls, falls der Knoten noch nicht existiert.
    \item \enquote{create\_or\_append} ignoriert den vorherigen Zustand.
    Dieser Modus wird nur den automatischen Prozessen exponiert, da die Erwartungshaltung im manuellen Format angegeben werden soll.
\end{itemize}

\subsection{Matching von Repräsentationen}\label{subsec:model-matching}
% Artefaktselektoren und Vererbungsregeln

% Die \texttt{identification}-Sektion enthält Attribute wie \texttt{type} (z.B. \texttt{python}, \texttt{npm}), \texttt{name} und typspezifische \texttt{typeAttributes} (z.B. \texttt{scope}, \texttt{packageName} für NPM oder \texttt{supplier} für Java Runtimes), die eine präzise Identifikation des Artefakts ermöglichen.
% Beispielsweise identifiziert der \texttt{artifact: "Redis Python Interface"}-Knoten Artefakte vom Typ \texttt{python} mit dem \texttt{name} \texttt{redis}.
% Die Möglichkeit, Listen von Werten für Attribute wie \texttt{Id} oder \texttt{name} zu definieren, erlaubt eine ODER-Verknüpfung von Matching-Kriterien, wodurch verschiedene Ausprägungen eines Attributs abgedeckt werden können.
% Die Unterstützung regulärer Ausdrücke, wie \texttt{redis-*/i} im \texttt{artifact: "Redis DB"}-Knoten, bietet zusätzliche Flexibilität bei der Mustererkennung.
% Das Vererbungssystem für Artefakt-Selektoren (\hyperref[subsec:req-selektor-inheritance]{A-04}), visualisiert durch \texttt{INH}-Kanten im Dot-Graphen (z.B. von \texttt{n17} zu \texttt{n16}), ermöglicht es, generische Matching-Regeln zu definieren und spezifischere Regeln davon abzuleiten, was die Redundanz reduziert und die Pflege erleichtert.

% Der Matching-Prozess im neuen Korrelationssystem ist darauf ausgelegt, eingehende Software-Artefakte präzise und effizient mit den im Graphen modellierten Produktrepräsentationen abzugleichen.
% Dieser Prozess beginnt mit der Analyse eines vorliegenden Artefakts, das beispielsweise aus einem Software-Scan oder einer \acrshort{sbom} stammt.

% Der erste entscheidende Schritt ist die **Typinferenz**, wie in \hyperref[subsec:req-type-specific-matching]{A-03} gefordert.
% Eine dedizierte Logik bereitet den Artefakttypen konsistent aus multiplen Quellen auf.
% Ziel ist es, einen normalisierten Ökosystembezeichner (z.B. \texttt{java-module}, \texttt{npm-package}, \texttt{python-module}) zu ermitteln.
% Diese Normalisierung ist entscheidend, um die Herausforderung inkonsistenter Typinformationen (\hyperref[subsec:c-02-uneindeutige-artefakt-typinformation]{C-02}) zu lösen und eine einheitliche Grundlage für den Abgleich zu schaffen.

% Basierend auf dem erkannten Ökosystem oder Typ des Artefakts werden anschließend **typspezifische Extraktoren** angewendet.
% Diese Extraktoren ziehen weitere Attribute aus den Artefakt-Metadaten, die als First-Class Matching-Kriterien dienen.
% Beispiele hierfür sind Maven-Koordinaten (Group Id, Artifact Id) für Java-Artefakte, spezifische Paketnamen für NPM-Pakete, oder Distributionskennungen für Linux-Pakete.
% Durch die Nutzung dieser präzisen, ökosystemspezifischen Attribute können unpräzise Wildcard-Selektoren, die im alten System häufig in der \texttt{Id} verwendet wurden (\hyperref[subsec:c-01-unspezifische-identifikation-von-artefakten]{C-01}), weitestgehend durch exakte Vergleiche ersetzt werden, was die Präzision und Zuverlässigkeit des Matchings erheblich steigert.
% Sollte kein bekannter Typ konkret erkannt werden können, wird das Artefakt dennoch mit seinen Basisattributen zum Abgleich zur Verfügung gestellt, um eine grundlegende Identifikation zu ermöglichen.

% Die eigentliche Matching-Logik vergleicht die extrahierten Artefaktattribute mit den in den \texttt{artifact}-Knoten des Graphen definierten **Selektor-Blöcken** (dem \texttt{identification}-Feld im \acrshort{yaml}-Format).
% Dabei kommt das in \hyperref[subsec:req-selektor-inheritance]{A-04} beschriebene **Vererbungssystem von Artefaktmerkmalen** zum Tragen.
% Ein Basis-Selektor kann generische Attribute definieren (z.B. Attribute, die für alle Microsoft Windows-Varianten gelten), während abgeleitete Selektoren spezifische Erweiterungen (z.B. die Architektur) hinzufügen.
% Lokale Attributdefinitionen in abgeleiteten Selektoren überschreiben dabei geerbte Werte.
% Dies verhindert die Duplizierung von Artefakt-Selektoren (\hyperref[subsec:c-03-duplizierte-artefakt-selektoren]{C-03}) und vereinfacht die Pflege von Korrelationsregeln.

% Die Anforderung \hyperref[subsec:req-multiple-attribute-values]{A-05} zur **Auflistung mehrerer Werte pro Attribut** wird ebenfalls im Matching-Prozess berücksichtigt.
% Wenn ein Attribut in einem Selektor mehrere Werte als Liste enthält, wird eine logische ODER-Verknüpfung angewendet.
% Das bedeutet, dass ein Match zustande kommt, sobald der Wert des eingehenden Artefakts mit mindestens einem der gelisteten Werte übereinstimmt.
% Trotz des Fokus auf typspezifische Attribute wird die **Unterstützung regulärer Ausdrücke** (\hyperref[subsec:req-regex-support]{A-06}) beibehalten, um weiterhin flexible und inkrementelle Wildcard-Systeme für komplexe Match-Fälle zu ermöglichen, die nicht rein über exakte Attribute abgebildet werden können.

% Das Ergebnis des Matching-Prozesses ist die Identifikation eines oder mehrerer \texttt{artifact}-Knoten im Graphen, die dem eingehenden Software-Artefakt entsprechen.
% Diese gefundenen Knoten dienen als Ausgangspunkte für die anschließende **Durchquerung des Graphen**, um die vollständige Produktidentifikation und alle zugehörigen Informationen zu ermitteln.

\subsection{Durchquerungsregeln des Graphen}\label{subsec:model-traversal}
% Auswertungslogik für Relationen und Versionstransformation

% Nachdem ein eingehendes Artefakt erfolgreich einem oder mehreren \texttt{artifact}-Knoten im Graphen zugeordnet wurde, beginnt die Phase der Graphen-Durchquerung.
% Diese dient dazu, die vollständige Produktidentifikation zu ermitteln und alle relevanten Repräsentationen sowie zugehörige Metainformationen zu aggregieren.
% Die Durchquerungslogik wird maßgeblich durch die Eigenschaften des gerichteten Graphen und die expliziten Abhängigkeitsdeklarationen gesteuert, wie in \hyperref[subsec:req-format-product-graph]{A-01} beschrieben.

% Die Kanten im Graphen sind gerichtet, was eine eindeutige Interpretation der \enquote{is}- und \enquote{is not}-Beziehungen ermöglicht.
% Die Durchquerung startet typischerweise bei dem gematchten Artefakt-Knoten und folgt den Kanten, um alle erreichbaren Knoten zu finden und deren Beziehungen auszuwerten.
% Dies beinhaltet sowohl positive Beziehungen (\enquote{is}-Kanten, intern \texttt{REP:APPLICABLE}) als auch explizite Ausschlüsse (\enquote{is not}-Kanten, intern \texttt{REP:INAPPLICABLE}). Die Richtung der Kante ist dabei entscheidend: Eine Kante von A nach B bedeutet, dass B durch A repräsentiert wird oder von A abhängt.
% Falls es nötig ist, kann eine identische, umgekehrte Kante dazu verwendet werden, um die Richtung der Kante auf beide Seiten zu erweitern, was eine bidirektionale Navigation ermöglicht, wenn dies für die Informationssuche relevant ist.

% Ein zentrales Ziel der Durchquerung ist die Verbindung der Artefakt-Repräsentationen mit den **Produkt-Knoten** (\hyperref[subsec:req-product-concept]{A-02}). Produkt-Knoten dienen als logische Klammer und zentrale Ankerpunkte für alle zugehörigen Repräsentationen eines Software-Produkts.
% Die Durchquerung bewegt sich von den initial gefundenen \texttt{artifact}-Knoten über \enquote{is}-Beziehungen zu den entsprechenden \texttt{product}-Knoten.
% Von einem Produkt-Knoten aus können dann weitere Repräsentationen wie \acrshortpl{cpe}, \acrshortpl{purl}, \acrshort{ms} Product IDs oder \acrshort{eol}-IDs identifiziert werden, die alle dasselbe logische Produkt beschreiben.
% Diese Produkt-Knoten speichern auch wichtige Metainformationen über Versionsräume und Transformationsregeln zwischen verschiedenen Versionierungsstandards, wie in \hyperref[subsec:req-product-concept]{A-02} gefordert.
% Dies ermöglicht es, unterschiedliche technische Identifikatoren unter einem einheitlichen Produktbegriff zu aggregieren und bei Bedarf Versionsinformationen zu normalisieren.

% Die explizite Deklaration von Abhängigkeiten zwischen Knoten durch die gerichteten Kanten ist essenziell.
% Sie erzwingt eine **topologische Sortierung** während der Verarbeitung, was implizite Dateireihenfolgeabhängigkeiten vollständig beseitigt (\hyperref[subsec:c-10-order-dependency]{C-10}). Dies gewährleistet, dass die Korrelationslogik stets in einer konsistenten und reproduzierbaren Reihenfolge ausgeführt wird, unabhängig von der physischen Anordnung der Daten im Speicher oder Dateisystem.

% Ein wesentlicher Aspekt der Durchquerung sind die **Qualitätsmetriken des Graphen** (\hyperref[subsec:req-graph-inner-consistency]{A-10}). Die Durchquerungslogik muss sicherstellen, dass bestimmte Eigenschaften des Graphen während der Auflösung eingehalten werden:
% \begin{itemize}
%     \item \textbf{Eindeutige Identifikation}: Zu jeder Repräsentation eines Produkts im Graphen darf maximal genau eine eindeutige Identifikation stattfinden.
%     Dies bedeutet, dass ein eingehendes Artefakt schlussendlich zu einem oder keiner eindeutigen Produktidentifikation führen sollte.
%     Konfliktierende Pfade zu unterschiedlichen Produkten, die von derselben Repräsentation ausgehen, würden als Inkonsistenz erkannt.
%     \item \textbf{Keine losen Knoten}: Jede Repräsentation muss mindestens zu einem Produkt-Knotenpunkt verbunden sein.
%     Dies stellt sicher, dass jede Identifikation einen Informationsgewinn bietet und nicht isoliert im System existiert.
%     Knoten, die zwar existieren, aber zu keinem Produkt in Beziehung stehen, adressieren \hyperref[subsec:c-06-falle-ohne-aktion-konnen-nicht-dokumentiert-werden]{C-06}, indem sie zwar modelliert, aber als unvollständig erkannt werden können.
%     \item \textbf{Sich selbst erklärender Datensatz}: Die Durchquerung muss Metadaten an Knotenpunkten und Begründungen an Kanten nutzen, um eine vollständige und nachvollziehbare Erklärung der Identifikationsentscheidungen zu bieten, wie in \hyperref[subsec:req-reason-format]{A-08} gefordert.
%     \item \textbf{Sich selbst prüfender Datensatz}: Nachdem ein Software-Inventar manuell geprüft wurde, werden die resultierenden Identifikationen in einem separaten Datensatz abgelegt.
%     Bei zukünftigen Graphen-Änderungen kann dieser Datensatz als Referenz dienen, um automatisiert zu prüfen, ob sich die Identifikation bekannter Produkte unerwartet geändert hat.
%     Dies erhöht die Stabilität und Zuverlässigkeit des Systems.
%     \item \textbf{Keine zirkulären Vererbungs-Referenzen}: Die Durchquerungslogik prüft auch auf Schleifen in Vererbungsbeziehungen, um sicherzustellen, dass es immer einen spezifischeren Knoten gibt und die Hierarchie der Vererbung eindeutig bleibt.
% \end{itemize}

% Die Fähigkeit des Systems, den gesamten Graphen aus generierten Daten zu befüllen und darauf die manuellen Modifikationen anzuwenden (\hyperref[subsec:req-generated-data]{A-09}), ist ein integraler Bestandteil der Durchquerungsstrategie.
% Zuerst wird der generierte Anteil des Graphen erstellt, der eine breite Basis an bekannten Identifikationen bietet.
% Anschließend werden die manuellen Modifikationen auf diesem generierten Graphen angewendet, um Korrekturen und Präzisierungen vorzunehmen.
% Diese Schichtenbauweise ermöglicht eine effiziente Verwaltung und erleichtert die Verteilung von öffentlichen Datensätzen vor der Anwendung spezifischer manueller Anpassungen (\hyperref[subsec:c-09-sharing-of-public-data]{C-09}).

\subsection{\acrshort{yaml}-Format für Graphmodifikationen}\label{subsec:modell-graph-modification-yaml}

Über einen iterativen Designprozess wurde ein \acrshort{yaml}-basiertes Format entwickelt, um die Nutzerfreundlichkeit des Formats zu gewährleisten (\hyperref[subsec:req-manual-format-modification]{A-07}).
Das Format muss auf dem Modifikationsformat aufbauen und sich darin abbilden lassen.
Eine Priorität des Formats war nicht nur die Lesbarkeit und Einfachheit das \acrshort{yaml} zu schreiben, sondern auch die Länge der einzelnen Einträge so kurz wie möglich zu halten.

Die oberste Ebene des \acrshort{yaml}-Dokuments ist eine Liste, in der jeder Eintrag eine Modifikation an einem Knoten, und damit in den meisten Fällen einen Knoten im Graphen darstellt.
Um die Identifikation eines Knotens so kurz und einfach wie möglich zu gestalten, wird Knotentyp (z.\ B. \texttt{cpe}, \texttt{product}, \texttt{artifact}) als Top-Level-Schlüssel verwendet, dessen Wert die eindeutige Id des Knotens enthält.
Dies aggregiert zwei Attribute in eines und spart damit Zeilen und kann dennoch problemlos erkannt werden, da alle Knotentyp-Bezeichner bekannt sind.
Zudem wird dieses Muster (\enquote{type: id}) immer wieder im Format verwendet und schafft damit eine einheitliche Weise, wie Knoten selektiert werden.
Da im Moment keine der geplanten Knotentypen, neben Produkt- und Artefakt-Knoten, weitere komplexen identifizierenden Attribute besitzen, wurde diese Adressierungslogik noch weiter vereinfacht, sodass direkt eine Repräsentation des gegebenen Typs angegeben werden kann und daraus nach den Regeln aus \autoref{subsubsec:model-graph-knoten} eine Id erzeugt wird.
Beispielsweise wird ein \texttt{artefact}-Knoten durch \texttt{artifact: "npm @material / banner"} adressiert, oder ein Knoten vom Typ \texttt{cpe} durch \texttt{cpe: "cpe:/a:redis:redis"} angegeben, woraus automatisch die Id \texttt{a:redis:redis} abgeleitet wird.

An Knoten können mit \texttt{metadata} diverse Metadaten angefügt werden (\hyperref[subsec:req-reason-format]{A-08}).
Das \texttt{metadata}-Feld ermöglicht es Beschreibungen (\texttt{description}) und externe Referenzen (\texttt{references}) unter beliebigen Keywords wie \texttt{homepage} abzulegen.

Kantenbeziehungen werden innerhalb der Knotendefinitionen unter den festgelegten Schlüsseln \texttt{is}, \texttt{is not} und \texttt{inherit}.
Die Felder enthalten je eine Liste von Zielknotenselektoren, zu denen die Beziehung aufgebaut werden soll, deren Format ebenfalls das \enquote{type: id}-Schema verwenden.

Typspezifisch sind momentan nur für Produkt- und Artefakt-Knoten weitere Attribute geplant.
Bei Artefakten ist das \texttt{identification}-Attribut, welches eine Liste von Selektoren mit den Kriterien für das Matching von eingehenden Artefakten enthält.
Nach \hyperref[subsec:req-type-specific-matching]{A-03} ermöglicht es die Verwendung von normalisierten Ökosystembezeichnern (\texttt{type}, z.B. \texttt{python}, \texttt{npm}) und typspezifischen Attributen (\texttt{name}, \texttt{scope}, \texttt{packageName}), die über spezielle Extraktoren ermittelt werden.
Wildcard-Selektoren \hyperref[subsec:req-regex-support]{A-06} können noch immer im alten Format inkrementell aktiviert werden.
Um mehrere Werte pro Attribut angeben zu können (\hyperref[subsec:req-multiple-attribute-values]{A-05}), können statt wie bisher nur Text-Werte auf den Attributen auch \acrshort{yaml}-Listen angegeben werden, deren Elemente durch eine logische ODER-Verknüpfung verbunden werden (z.B. \texttt{name: ["web3-react\_walletconnect", "walletconnect", "@web3-react/walletconnect"]}).

\begin{lstlisting}[style=yaml,caption={Beispiel des \acrshort{yaml}-Modifikationsformats},label={lst:modell-graph-modification-yaml-demo},basicstyle=\ttfamily\scriptsize]
- cpe: "cpe:/a:ellucian:banner"
  metadata:
    description: "Student information system"
    references:
      homepage: https://www.ellucian.com

- artifact: "npm @material / banner"
  identification:
    - type: npm
      scope: "@material"
      packageName: "banner"
  is:
    - product: "NPM Material Design Banner Component"

- product: "NPM Material Design Banner Component"
  is not:
    - cpe: "a:ellucian:banner"
      why: "Refers to an Enterprise SIS system"
      because:
        - "Ellucian Banner is student information software"
        - "No relation to web components"
\end{lstlisting}

\begin{figure}[htbp]
    \centering
    \makebox[\textwidth]{\includesvg[width=1.3\textwidth, inkscapelatex=false]{bilder/example-graph-material-banner}}
    \caption{Generierter Graph aus dem Beispiel des \acrshort{yaml}-Modifikationsformats}
    \label{fig:modell-graph-modification-yaml-demo-rendered}
\end{figure}

% Das in \hyperref[subsec:req-selektor-inheritance]{A-04} geforderte Vererbungssystem für Artefakt-Selektoren wird ebenfalls durch das \acrshort{yaml}-Format abgebildet.
% Obwohl nicht direkt im bereitgestellten Beispiel sichtbar, würde dies typischerweise durch ein zusätzliches Feld wie \texttt{inherits} oder ähnliche Mechanismen innerhalb der Artefakt-Selektor-Definitionen realisiert.
% Dies erlaubt die Definition generischer Basis-Selektoren, von denen spezifischere Selektoren Attribute erben und bei Bedarf überschreiben können, was die Wartung von Selektoren erheblich vereinfacht und Duplizierung reduziert (\hyperref[subsec:c-03-duplizierte-artefakt-selektoren]{C-03}).

% Um der Herausforderung großer und unübersichtlicher \acrshort{yaml}-Dateien (\hyperref[subsec:c-04-groe-und-unubersichtliche-yaml-dateien]{C-04}) zu begegnen, wird die Organisation der manuell gepflegten Korrelationsdateien gemäß \hyperref[subsec:req-yaml-file-organization]{A-11} neu strukturiert.
% Es wird eine Trennung in Verzeichnissen nach Typ und/oder Ökosystem vorgenommen, und innerhalb dieser Verzeichnisse können einzelne Hersteller- oder Produktgruppen in separaten Dateien geführt werden.
% Diese modulare Struktur verbessert die Übersichtlichkeit, erleichtert die Navigation und fördert die Zusammenarbeit.

% Schließlich wird die Überführung bestehender Einträge aus dem alten Korrelationsdatensatz (\hyperref[subsec:req-current-dataset-conversion]{A-12}) duch die Fähigkeit des neuen Formats unterstützt, die Funktionalitäten des alten Systems vollständig abzubilden und zu erweitern.
% Dies ermöglicht einen parallelen Betrieb und eine schrittweise Migration der Daten, um einen reibungslosen Übergang zum neuen System zu gewährleisten.
