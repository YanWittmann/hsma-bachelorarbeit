\section{Modell des neuen Korrelationssystems}\label{sec:model-modellierungsansatz}

Aufgrund der abgeleiteten Anforderungen und den Referenzfällen wird in den folgenden Unterkapiteln das neue Korrelationssystem mit der Struktur des Graphen, einem Modifikationsformat um den Graphen zu transformieren, dem \acrshort{yaml}-Format um die Modifikationen manuell durchführen zu können, und die Matching- und Durchquerungsregeln für die Auswertung von Repräsentationsauflösungen.

\subsection{Struktur des Graphen}\label{subsec:model-graph-struktur}

Wie in \hyperref[subsec:req-format-product-graph]{A-01} und \hyperref[subsec:req-product-concept]{A-04} gefordert, wird das neue Korrelationssystem mithilfe eines Graphens modelliert, in dem jeder Knotenpunkt entweder einem Produkt oder einer Repräsentation eines Produktes entspricht und durch Kanten verbunden sind, die die Beziehungen zwischen diesen modellieren.

\subsubsection{Knotenpunkte}\label{subsubsec:model-graph-knoten}

Betrachtet werden zunächst die Knotenpunkte der Repräsentationen von Produkten.
Für jedes Produktidentifikationsstandard-Ökosystem wird ein Typ für einen Knotenpunkt angelegt, der dem Knoten typspezifische Attribute und Eigenschaften zuweisen kann.
Diese definieren, wie sich ein Knoten selbst identifiziert und kann zum Abgleich von zugehörigen Repräsentationen mit sich selbst verwendet werden, um herauszufinden, ob eine reale Repräsentation einem Knotenpunkt entspricht.
Zudem kann diese Knoteninformation in Kombination mit dem Typen einer eingehenden Kante interpretiert werden, um eine Transformation an dem Ursprungsknotenpunkt anzuwenden.

Um jeden Knoten eindeutig ansprechen zu können und um die Eindeutigkeit eines Knotens zu sichern hat jeder Knoten im Datenmodell neben seinem Typen zusätzlich eine eindeutige Id.
Die Kombination aus Typ und Id ermöglicht eine genaue Identifikation.
Die Anforderung, dass sich jede Repräsentation eines Produkts in nur einem Knoten ausprägen darf, löst die Reihenfolgenabhängigkeit (\hyperref[subsec:c-10-order-dependency]{C-10}), da jede Identifikation nur einmal vorkommen kann und die weiteren Abhängigkeiten über weitere Kanten dargestellt werden.

Allgemein soll jeder Knoten, und jede Kante, in der Lage sein, Metadaten über sich selbst abzulegen.
Mehr Details dazu kann in \autoref{subsec:model-rationale} gefunden werden.

Die genauen Ausprägungen der initial geplanten Knotentypen und deren Attribute und Verhalten können im Folgenden betrachtet werden.
Der Produkt-Knotenpunkt wird in \autoref{subsubsec:model-product-node} detailliert beschrieben.
Um von Anfang an ein einheitliches Format für die Ids unterschiedlicher Typen zu sichern, wird zudem auch eine Regel angegeben, wie aus einer Repräsentation die entsprechende Id abgeleitet werden kann.

\begin{itemize}
    \itemsep0em
    \item \textit{\acrshort{cpe}}: repräsentieren genau eine \acrshort{cpe} mit einer Menge an gesetzten Parts, beispielsweise \texttt{cpe:/a:redis:redis}.
    Wenn ein solcher Knoten über eine \enquote{is}-Beziehung von einem Artefakt aus erreicht wird, wird die entsprechende \acrshort{cpe} dem Ziel-Artefakt als \texttt{Additional CPE URIs} hinzugefügt, und von \texttt{Inapplicable CPE URIs} entfernt.
    Bei \enquote{is not} passiert entsprechend das Gegenteil.
    Die Id eines \acrshort{cpe}-Knotens leitet sich aus der Menge an Doppelpunkt-getrennten Parts ab, die in der \acrshort{cpe} gesetzt sind, wobei Lücken zwischen gesetzten Parts immer mit \enquote{*} aufgefüllt werden müssen.
    Zu der redis-\acrshort{cpe} wäre die Id entsprechend: \texttt{a:redis:redis}.
    \item \textit{\acrshort{purl}}: verhält sich ähnlich wie ein \acrshort{cpe}-Knoten, es werden beliebige Attribute einer \acrshort{purl} abgelegt, auf die ein Artefakt geprüft werden kann.
    Bei \acrshortpl{purl} wird die Knoten-Id wie die \acrshort{purl} selbst, nur ohne den \texttt{pkg:}-Präfix geschrieben.
    \item \textit{MS Product ID}: stellen eine numerische Produkt-Id dar, und können optional anzuwendende KB-Nummern (Security-Patch Ids) enthalten.
    Ähnlich wie bei dem \acrshort{cpe}-Knoten werden Artefakten bei positiver oder negativer Übereinstimmung die Ids in dem Attribut \texttt{MS Product Id} hinzugefügt oder entfernt.
    Die Knoten-Id ist identisch mit der Produkt-Id.
    \item \textit{\acrshort{eol}-Id}: enthält genau eine Produkt-Id aus dem endoflife.date-Ökosystem und optional eine Referenz auf einen Zyklus innerhalb dieses Produkts.
    Die Knoten-Id ist identisch mit der Produkt-Id.
    \item \textit{Artefakt}: repräsentieren tatsächliche Software-Artefakte, die in einem Inventar aus einem Software-Scan oder einer \acrshort{sbom} gefunden werden können.
    In dem Nutzungskontext der Korrelationsdaten dienen sie als Ausgangspunkt für den Selektionsprozess und die anschließende Graphen-Durchquerung um Effekte auf ein Artefakt zu bestimmen.
    Ein Artefakt-Knoten besitzt einen Selektionsblock, der die Kriterien für die Artefakt-Selektion enthält.
    Die Selektionslogik wird in \autoref{subsubsec:model-matching} genauer ausgeführt.
\end{itemize}

Jeder Knotenpunkt kann optional eine Menge an \enquote{Namespaces} als eine Liste an Labels zugewiesen bekommen.
Diese Namespaces können auf beliebige Nutzungsfälle erweitert werden, sind im Moment jedoch ausschließlich für das Filtern von Transformationen geplant, die im folgenden Abschnitt erklärt werden.

Da eine Repräsentation im Graphen in nur einem Knoten ohne Wiederholung ausgeprägt sein soll, müssen Attribute wie Versionen oder Editionen für den Zielknoten aus dem Weg von dem selektierten Knoten zur Zielrepräsentation abgeleitet werden.
Dies wird durch \enquote{transform}-Anweisungen gelöst, die allgemein auf Kanten, aber auch speziell auf Produkt-Knoten angebracht sein können und dementsprechend unterschiedlich ausgewertet werden.
Produkt-Knoten werden in \autoref{subsubsec:model-product-node} spezifiziert.
Eine Transformation besitzt immer einen Anwendbarkeitsfilter, der auf Quell- und Zielknoteneigenschaften prüfen kann, und einen Effekt, der auf den Zielknoten bei erfolgreicher Prüfung beider Knoten angewendet werden kann, und eine Transformation, die auf einen Zielknoten angewendet werden soll.
Auf Kanten wird eine vereinfachte Form der Filtermechanismen eingesetzt, da hier die Quelle bereits bekannt ist und so nur noch auf das Ziel gefiltert werden muss, auf Produkt-Knoten können beide geprüft werden.
Filterattribute können der Typ, die Id, diverse typspezifische Attribute oder die Zugehörigkeit zu einem Namespace sein.
Sobald ein Transformationseintrag als zutreffend klassifiziert ist, werden an den Zielknoten die weiteren frei setzbaren Attribute des Eintrages weitergegeben, die dieser je nach Knotentyp und Kantentyp individuell auswerten kann.
Beispiele dafür sind bei \texttt{cpe}-Knoten die Attribute wie \texttt{version} oder \texttt{update}.
Auf diese Weise müssen Attribute nicht bereits in dem Knoten der Repräsentation modelliert sein, sondern können auf dem Weg von einer anderen Repräsentation dynamisch gesammelt werden.
Neben diesen freien Attributen gibt es auch noch weitere spezielle Schlüsselwörter, mit denen eine Zielrepräsentation völlig ignoriert werden kann (\texttt{discard}) oder der eingehende Kantentyp explizit gesetzt werden kann (\texttt{is}, \texttt{is not}).

\subsubsection{Produkt-Knoten}\label{subsubsec:model-product-node}
Produkt-Knoten sind eine spezielle Form von Knoten, die ein Software-Produkt wie in \autoref{subsec:produkte-vs-reprasentation} detailliert darstellen.
Sie enthalten im Gegensatz zu den konkreten Repräsentationsknoten keine Selektoren oder Informationen darüber, wie eine Repräsentation modifiziert werden soll, sondern dient als logische Klammer und zentraler Knoten für alle Repräsentationen, mit denen ein Produkt identifiziert werden kann.
So sollen Repräsentationen nicht direkt miteinander über Kanten verbunden werden, sondern einen Zwischenknoten definieren, der sie und potenziell weitere verbindet.

Um zu vermeiden, dass ähnlich wie im alten Korrelationssystem potenziell viele versionierte Ausprägungen einer gleichen Repräsentation als Knotenpunkte erstellt werden müssen, um versionierte \acrshortpl{cpe} zuordnen zu können, müssen Produkt-Knoten in der Lage sein, neben den normalen Begründungen und Referenzen auch weitere Metainformationen über die zugehörigen Repräsentationen abzulegen, vor allem Informationen über Versionsräume und wie zwischen diesen umgewandelt werden kann.
Diese Ansammlung an Metadaten und die Kanten zu Produktrepräsentation soll zu einem einheitlich aggregierten Produktkonzept führen.

\subsubsection{Kanten und Relationen}\label{subsubsec:model-edges-relations}
Die Kanten des Graphen sind gerichtete Beziehungen zwischen den Knotenpunkten und modellieren die logischen Verknüpfungen innerhalb des Korrelationssystems.
Die zwei primären Kantentypen sind \enquote{is} und \enquote{is not}.
Die Interpretation dieser Beziehungen liegt bei den Zielknoten, jedoch gilt allgemein das Folgende:

Die \enquote{is}-Kante (auch \enquote{is represented by}) drückt eine Zugehörigkeitsbeziehung aus.
Allgemein beschreibt sie, dass eine bestimmte Repräsentation die Ausgangsrepräsentation vollständig in einem anderen Ökosystem darstellt und für Anfragen in diesem verwendet werden kann.
Die \enquote{is not}-Kante (auch \enquote{is not represented by}) ist für einen expliziten Ausschluss der Anwendbarkeit einer Repräsentation auf einer Ausgangsrepräsentation zuständig und so Fehlidentifikationen explizit zu vermeiden.
So wird beispielsweise die positiv anwendbare Verknüpfung von Artefakt-Knoten mit Produkt-Knoten, und von Produkt-Knoten mit verschiedenen Standard-Identifikatoren (\acrshortpl{cpe}, \acrshortpl{purl} etc.) über \enquote{is}-Kanten realisiert, oder wenn ein Artefakt mit einem bestimmten Namen fälschlicherweise einer Produktfamilie zugeordnet werden könnte, kann eine \enquote{is not}-Kante die korrekte Trennung sicherstellen.

Beim Durchqueren des Graphen sind diese beiden Kantentypen jedoch nicht äquivalent auszuwerten, wie genauer in \autoref{subsubsec:model-traversal} beschrieben wird.
So überschreibt eine einzige Kante vom Typ \enquote{is not} bei allen direkt und indirekt darüber erreichbaren Knotenpunkten den Kantentyp ebenfalls auf \enquote{is not}.
Dies ist nötig, da es nicht korrekt wäre, eine Repräsentation als Anwendbar zu klassifizieren, nur weil die direkte Kante von der vorherigen Repräsentation sie als auf sich Anwendbar sieht.
Die Nicht-Anwendbarkeit wird also durch den Graphen propagiert.

Darüber hinaus existiert eine dritte Art von Kante, die eine Vererbung von Informationen repräsentiert (inheritance, \hyperref[subsec:req-selektor-inheritance]{A-07}).
Über diese sollen Basis-Eigenschaften von einem Eltern-Knoten an einen Kind-Knoten weitergegeben werden, mit dem Ziel, die Redundanz im Datenmodell zu reduzieren und die Pflege zu vereinfachen.
Im Stand dieser Arbeit sind zwei Anwendungsfälle für diese vorgesehen.
Mit der Verwendung dieses Kantentyps zwischen Artefakt-Knotenpunkten müssen zum erfolgreichen Matching eines Knotens auch alle darüberliegenden Knotenpunkte erkannt werden.
Bei der Auswahl der übereinstimmenden Artefakt-Knoten wird nur der spezifischste ausgewählt.
Der zweite Nutzungsfall sind Produkt-Knotenpunkte, bei denen auch alle geerbten Kanten zu anderen Knotenpunkten ausgewertet werden.
Eine Prüfung auf zirkuläre Vererbungs-Referenzen ist dabei nötig, um Schleifen zu verhindern und eine eindeutige Auflösung zu garantieren (\hyperref[subsec:req-graph-inner-consistency]{A-19}).

Falls es nötig ist, eine bidirektionale Beziehung darzustellen, kann mit einer identische, umgekehrten Kante die Richtung auf beide Seiten erweitert werden.

\subsection{Beschreibungen und Begründungen}\label{subsec:model-rationale}

Dieser Abschnitt teilt sich in zwei Unterkapitel, die das Format der Dokumentation von Metadaten auf Knoten und von Begründungen auf Kanten beschreiben.
Aus dem bestehenden Datensatz werden Muster identifiziert, wie diese bisher in der Regel angegeben wurden, anhand von denen diese neuen Formate entworfen werden.

\subsubsection{Kanten}

In \hyperref[subsec:c-05-reason-not-good-enough]{C-05} wurden einige Beispiele für bisherige Entscheidungsketten aufgeführt.
Jede Kette startet mit der Repräsentation, zu der es zu prüfen gilt, ob sie auf das aktuelle Artefakt anwendbar ist.
Jedes Element in der Kette stellt eine Referenz, ein Zitat, eine Begründung oder Ableitung dar, die im letzten Schritt verwendet werden, um ein Urteil über die Anwendbarkeit der Repräsentation zu fällen.

Der klare Vorteil von diesem Schema ist es, dass es sehr einfach ist, diese Ketten zu formulieren und während der Forschungsarbeit die einzelnen Schritte zu dokumentieren, da das Kommentarfeld formlos ist und jede Art von Inhalt erlaubt ist.
Jedoch kann ein Kommentar in \acrshort{yaml} nicht ausgewertet werden, und die Formlosigkeit erlaubt es, auch \enquote{falsch} formatierte Ketten aufzubauen.
Das neue Format soll also die Einfachheit und Erweiterbarkeit des alten Formats zu behalten, aber es auf eine Weise zu strukturieren, dass es Teil der Kantenangaben sein kann.
Da das Subjekt der Begründung bereits durch die Kantenrichtung festgelegt ist, muss nur die Begründungskette und das Urteil aufgenommen werden.

Daher wird das Urteil einfach in einem \enquote{why}-Attribut als Text abgelegt und die Begründung für diese als Liste an Texten in \enquote{because}, wobei jeder Eintrag in dieser Liste einem der ursprünglichen Schritte in der Kette entspricht (Referenz, \ldots).
Die Begründungsschritte sind nicht typisiert, um noch immer eine möglichst große Freiheit zu ermöglichen und zukünftige Begründungen nicht einzuschränken.

\subsubsection{Knoten}

In dieser initialen Version sind auf einem Knoten einer Repräsentation die relevanten Metadaten die Produktbeschreibung und eine Menge an Referenzen auf Webseiten wie die Projekte, Homepages, Dokumentationen oder weitere.
Die Beschreibung ist ein einfaches Textfeld, die Referenzen sind ein Objekt, bei dem die Schlüssel die Art der Referenz und der Wert der Link selbst ist.
Bisher festgelegte Referenztypen sind \enquote{homepage}, \enquote{repository}, \enquote{TODO}. % TODO: fill types
Um jedoch die Erweiterbarkeit zu sichern, kann als Schlüssel jeder Wert verwendet werden.

\subsection{Graphmodifikation}\label{subsec:model-graph-modification}

Um es nach \hyperref[subsec:req-manual-format-modification]{A-10} zu ermöglichen, auf eine normalisierte Weise den Graphen von den automatisierten oder manuellen Prozessen zu modifizieren, ist ein allgemeines Schema nötig, das von allen gleichermaßen verwendet werden kann.
Das Modifikationsformat muss grundlegende Operationen auf dem Graphen erlauben: die Erstellung, Änderung und Entfernung von Knotenpunkten jeden Typs sowie die Erstellung, Änderung und Entfernung von Kanten zwischen diesen Knoten.

Das Subjekt einer Modifikation ist ein typisierter Knotenpunkt, von dem die Metadaten oder angrenzenden Kanten modifiziert werden können.
Da jeder Knotenpunkt mit der Kombination aus Typ und Id eindeutig ist, ist die Angabe eines Typs und einer Id in der Modifikation unerlässlich.
Da die einzelnen Knotentypen jeweils dedizierte Metadaten enthalten, muss auch die Modifikation über den Typ Zugriff auf diese dedizierten Attribute der Knoten erhalten.
Im vorherigen Format war es eine Herausforderung, ursprüngliche Einträge in den \acrshort{yaml}-Dateien aus dem Datenmodell heraus wiederzufinden (\hyperref[subsec:c-11-finding-yaml-entries]{C-11}).
Dies ist im neuen System eine einfache Aufgabe, da die Einträge jeweils ihren Typ und die Id angeben müssen, um das Subjekt der Modifikation zu identifizieren.

Bei der Selektion können zwei Szenarien auftreten: der Knoten existiert bereits, oder er tut es noch nicht.
Die Modifikationen operieren überschreibend oder erweiternd auf Knotenpunkten, sie fügen ihre Informationen zu diesen hinzu oder überschreiben vorhandene Attribute.
Für die einzelnen Attribute muss dementsprechend festgelegt werden, wie sie sich bei einer Erweiterung oder beim Überschreiben verhalten.
Falls ein Knotenpunkt dem Graphen noch nicht bekannt ist, kann er einfach durch die Kombination aus Typ und Id angelegt, und die Modifikation auf diesen neuen Knoten angewendet werden.
Da die automatisierten Generierungsprozesse in der Regel für ihre Modifikationen nicht daran interessiert sind, ob ein Knotenpunkt bereits existiert oder nicht, sondern einfach ihre Relationen oder Metadaten hinzufügen wollen, kann hier der vorherige Zustand ignoriert werden und die Modifikation auf den neuen oder bereits vorhandenen angewendet werden.

Für den Fall der manuellen Modifikation muss jedoch die Erwartungshaltung an den vorherigen Zustand in der Modifikation festgehalten werden.
Dies liegt daran, dass wenn bisher ein Knoten erzeugt werden musste, weil es ihn noch nicht gab, und er dann auf einmal durch eine Änderung der automatisierten Datenquellen doch bereits vorhanden ist, muss manuell geprüft werden, ob dies noch immer das erwartete Verhalten bewirkt.
Der umgekehrte Fall ist ebenso relevant, falls ein Knotenpunkt auf einmal aus einer Datenquelle verschwinden sollte, will man dies mitbekommen.

Zudem muss es die Möglichkeit geben, Informationen aus einem Knoten wieder zu entfernen.
Da dies in der Analysephase des Projekts immer gut durch das Überschreiben von Kantentypen oder Überschreiben von anderen Attributen gelöst werden konnte, wird hier der einfache Ansatz einer \enquote{reset}-Modifikation gewählt, der einen Knotenpunkt vollständig zurücksetzt und alle ein- und ausgehenden und Kanten entfernt.

Daraus ergeben sich die folgenden Modifikationsmodi:

\begin{itemize}
    \itemsep0em
    \item \enquote{create} geht davon aus, dass ein Knoten noch nicht existiert.
    Er wird den Modifikationsprozess zum Stoppen bringen, falls der Knoten bereits existierte, hat aber sonst keine weiteren Effekte.
    Der Erstellungsmodus ist der Standard-Modus, da dieser in Tests der am häufigsten verwendete war.
    \item \enquote{append} erwartet, dass der Knoten bereits existiert.
    Bei ihm wird der Prozess gestoppt, falls er noch nicht existiert.
    \item \enquote{reset} erwartet, dass der Knoten bereits existiert, und setzt all seine Attribute und Kanten zurück.
    Er stoppt den Prozess ebenfalls, falls der Knoten noch nicht existiert.
    \item \enquote{create\_or\_append} ignoriert den vorherigen Zustand.
    Dieser Modus wird nur den automatischen Prozessen exponiert, da die Erwartungshaltung im manuellen Format angegeben werden soll.
\end{itemize}

\subsection{\acrshort{yaml}-Format für Graphmodifikationen}\label{subsec:modell-graph-modification-yaml}

Über einen iterativen Designprozess wurde ein \acrshort{yaml}-basiertes Format entwickelt, um die Nutzerfreundlichkeit des Formats zu gewährleisten (\hyperref[subsec:req-manual-format-modification]{A-10}).
Das Format muss auf dem Modifikationsformat aufbauen und sich darin abbilden lassen.
Eine Priorität des Formats war nicht nur die Lesbarkeit und Einfachheit das \acrshort{yaml} zu schreiben, sondern auch die Länge der einzelnen Einträge so kurz wie möglich zu halten.

Die oberste Ebene des \acrshort{yaml}-Dokuments ist eine Liste, in der jeder Eintrag eine Modifikation an einem Knoten, und damit in den meisten Fällen einen Knoten im Graphen darstellt.
Um die Identifikation eines Knotens so kurz und einfach wie möglich zu gestalten, wird Knotentyp (z.\ B. \texttt{cpe}, \texttt{product}, \texttt{artifact}) als Top-Level-Schlüssel verwendet, dessen Wert die eindeutige Id des Knotens enthält.
Dies aggregiert zwei Attribute in eines und spart damit Zeilen und kann dennoch problemlos erkannt werden, da alle Knotentyp-Bezeichner bekannt sind.
Zudem wird dieses Muster (\enquote{type: id}) immer wieder im Format verwendet und schafft damit eine einheitliche Weise, wie Knoten selektiert werden.
Da im Moment keine der geplanten Knotentypen, neben Produkt- und Artefakt-Knoten, weitere komplexen identifizierenden Attribute besitzen, wurde diese Adressierungslogik noch weiter vereinfacht, sodass direkt eine Repräsentation des gegebenen Typs angegeben werden kann und daraus nach den Regeln aus \autoref{subsubsec:model-graph-knoten} eine Id erzeugt wird.
Beispielsweise wird ein \texttt{artefact}-Knoten durch \texttt{artifact: "npm @material / banner"} adressiert, oder ein Knoten vom Typ \texttt{cpe} durch \texttt{cpe: "cpe:/a:redis:redis"} angegeben, woraus automatisch die Id \texttt{a:redis:redis} abgeleitet wird.

An Knoten können mit \texttt{metadata} diverse Metadaten angefügt werden (\hyperref[subsec:req-reason-format]{A-12}).
Das \texttt{metadata}-Feld ermöglicht es Beschreibungen (\texttt{description}) und externe Referenzen (\texttt{references}) unter beliebigen Keywords wie \texttt{homepage} abzulegen.

Typspezifisch sind momentan nur für Produkt- und Artefakt-Knoten weitere Attribute geplant.
Bei Artefakten ist das \texttt{identification}-Attribut, welches eine Liste von Selektoren mit den Kriterien für das Matching von eingehenden Artefakten enthält.
Nach \hyperref[subsec:req-type-specific-matching]{A-06} ermöglicht es die Verwendung von normalisierten Ökosystembezeichnern (\texttt{type}, z.B. \texttt{python}, \texttt{npm}) und typspezifischen Attributen (\texttt{name}, \texttt{scope}, \texttt{packageName}), die über spezielle Extraktoren ermittelt werden.
Wildcard-Selektoren können noch immer im alten Format inkrementell aktiviert werden (\hyperref[subsec:req-regex-support]{A-09}).
Um mehrere Werte pro Attribut angeben zu können (\hyperref[subsec:req-multiple-attribute-values]{A-08}), können statt wie bisher nur Text-Werte auf den Attributen auch \acrshort{yaml}-Listen angegeben werden, deren Elemente durch eine logische ODER-Verknüpfung verbunden werden (z.B. \texttt{name: ["web3-react\_walletconnect", "walletconnect", "@web3-react/walletconnect"]}).

Kantenbeziehungen werden innerhalb der Knotendefinitionen unter den festgelegten Schlüsseln \texttt{is}, \texttt{is not} und \texttt{inherit}.
Die Attribute enthalten je eine Liste von Zielknotenselektoren, zu denen die Beziehung aufgebaut werden soll, deren Format ebenfalls das \enquote{type: id}-Schema verwenden.
Auf dem gleichen Objekt werden zudem die Metadaten der Kante aufgeführt, die sie haben soll.
Diese sind einmal die Begründungsfelder \texttt{why} mit der aus der Nachforschung abgeleiteten Entscheidung als Textattribut aufgenommen werden kann und \texttt{because}, in der die Begründung schrittweise als Text-Liste steht.

Neben diesen Metadaten gibt es auf Kanten die \texttt{transform}-Anweisung, in der eine Liste an Transformationen an einen Zielknoten definiert, um dessen Bedeutung zu verändern.
Neben den Transformationsattributen nimmt jeder Eintrag optional eine Anwendbarkeitsbedingung in dem Attribut \texttt{for} aufgeführt werden, die den Zielknoten auf einen Typen, die Id und weitere Attribute filtern kann.
Auf Produkt-Knoten geschieht die Definition von Transformationen in dem \texttt{namespaces}-Attribut, welcher ein Objekt darstellt.
Jeder Schlüssel in diesem Objekt stellt den Bezeichner eines Namespaces dar, den sowohl Quell- als auch Zielknoten besitzen müssen, um überhaupt in Frage zu kommen.
In den Objekt-Werten sind über das \texttt{source}-Attribut weitere Filter auf den Quellknoten möglich, in \texttt{target} werden die anzuwendenden Transformationen aufgelistet.

Die Begründungsfelder sind genau wie in \autoref{subsec:model-rationale} erklärt auf den Knoten und Kanten als Objekte und Listen verfügbar.

Ein einfaches Beispiel für die Definition von drei Knoten und zwei Kanten kann in \autoref{lst:modell-graph-modification-yaml-demo} im \acrshort{yaml}-Format gefunden werden, wie sich die Auswertung davon im Graphen darstellt ist in \autoref{fig:modell-graph-modification-yaml-demo-rendered} abgebildet.
Um die Fähigkeiten des Formats als \textit{Modifikations}format zu demonstrieren wird auf dem vorherigen Graphen mit einer weiteren Modifikation in \autoref{lst:modell-graph-modification-yaml-demo-append} aufgebaut, woraus sich der Graph in \autoref{fig:modell-graph-modification-yaml-demo-append-rendered} ergibt.
Weitere Beispiele und die Referenzfälle können in \autoref{sec:beispiele-fertige-implementierung} gefunden werden.

\begin{lstlisting}[style=yaml,caption={Beispiel des \acrshort{yaml}-Modifikationsformats (create mode)},label={lst:modell-graph-modification-yaml-demo},basicstyle=\ttfamily\scriptsize]
- cpe: "cpe:/a:ellucian:banner"
  metadata:
    description: "Student information system"
    references:
      homepage: https://www.ellucian.com

- artifact: "npm @material / banner"
  identification:
    - type: npm
      scope: "@material"
      packageName: "banner"
  is:
    - product: "NPM Material Design Banner Component"

- product: "NPM Material Design Banner Component"
  is not:
    - cpe: "a:ellucian:banner"
      why: "Refers to an Enterprise SIS system"
      because:
        - "Ellucian Banner is student information software"
        - "No relation to web components"
\end{lstlisting}

\begin{figure}[htbp]
    \centering
    \makebox[\textwidth]{\includesvg[width=1.3\textwidth, inkscapelatex=false]{bilder/example-graph-material-banner}}
    \caption{Generierter Graph aus dem Beispiel des \acrshort{yaml}-Modifikationsformats (create mode)}
    \label{fig:modell-graph-modification-yaml-demo-rendered}
\end{figure}

\begin{lstlisting}[style=yaml,caption={Beispiel des \acrshort{yaml}-Modifikationsformats (append mode)},label={lst:modell-graph-modification-yaml-demo-append},basicstyle=\ttfamily\scriptsize]
- cpe: "cpe:/a:blogstand_banner_plugin_project:blogstand-smart-banner"

- product: "NPM Material Design Banner Component"
  mode: append
  is not:
    - cpe: "a:blogstand_banner_plugin_project:blogstand-smart-banner"
      why: "Not a Material Design component, is an abandoned WordPress plugin"
      because:
        - "affects CVE-2014-4848"
        - "http://packetstormsecurity.com/files/127290/WordPress-Blogstand-Smart-Banner-1.0-Cross-Site-Scripting.html"
        - "http://wordpress.org/plugins/blogstand-smart-banner"
        - "This plugin has been closed"
        - "Only one version released 12 years ago"
\end{lstlisting}

\begin{figure}[htbp]
    \centering
    \makebox[\textwidth]{\includesvg[width=1.3\textwidth, inkscapelatex=false]{bilder/example-graph-material-banner-append}}
    \caption{Generierter Graph aus dem Beispiel des \acrshort{yaml}-Modifikationsformats (append mode)}
    \label{fig:modell-graph-modification-yaml-demo-append-rendered}
\end{figure}

\subsection{Auswertung des Graphen anhand eines Artefakts}\label{subsec:model-apply-to-artifact}

Der Fokus dieser Arbeit liegt darauf, den Produktgraphen für das neue Korrelationssystem vorzubereiten.
Da in diesem Kontext die Traversierungsrichtung immer von Artefakt-Knoten zu anderen Repräsentationen ausgeht, wird zunächst der Fokus nur auf den Abgleich von Knoten des Typs \texttt{artefact} mit Artefakten gelegt.
Die hier aufgeführten Regeln lassen sich daraus jedoch auch recht einfach für weitere Knotentypen ableiten.

Das Anwenden von Informationen aus dem Graphen auf ein Referenzartefakt erfolgt in vier getrennten Schritten, die jeweils eine definierte Ausgabe bereitstellen.

\begin{enumerate}
    \itemsep0em
    \item Artefakt-Typ-Erkennung: Typspezifische Attribute werden aus dem Artefakt abgeleitet, die in der Selektion ausgewertet werden können.
    \item Knoten-Identifikation: Die Selektoren der Artefakt-Knoten im Graphen werden ausgewertet, um zutreffende Artefakt-Knoten zu finden.
    \item Graph-Traversierung: Von den identifizierten Knoten aus werden erreichbare Repräsentationen ermittelt und Metadaten auf dem Weg dorthin aggregiert.
    \item Anwendung: Gefundene Knoten wenden ihre typspezifische Logik auf das ursprüngliche Artefakt an, um es zu transformieren.
\end{enumerate}

Diese Schritte werden in den folgenden Unterkapiteln detailliert.

\subsubsection{Matching von Artefakt-Repräsentationen}\label{subsubsec:model-matching}

Eine der Qualitätsanforderungen an den Graphen (\hyperref[subsec:req-graph-inner-consistency]{A-19}) ist, dass genaue eine Repräsentation im Graphen mit einer Eingabe übereinstimmt.
Das bedeutet auch, dass bei der Abfrage eines Artefakts nur ein einiger Knoten gefunden werden darf, der diesem entspricht.
Es werden dafür in Folgenden zwar Mechanismen bereitgestellt, die dieses Verhalten möglichst einfach für einen Anwender ermöglichen, jedoch kann die explizite manuelle Modellierung eines solchen Falles nicht von der Konzeption her ausgeschlossen werden.
Daher ist es so wichtig, einen sich selbst pflegenden Testdatensatz zu führen, der die Identifikationen regelmäßig automatisch prüft.

In den nächsten Kapiteln wird wird zunächst die Artefakt-Selektion auf einzelnen Knoten eingeführt, dann werden mehrere Knoten über Vererbungsregeln kombiniert und deren Regeln erläutert.

\paragraph{Artefakt-Typ-Erkennung}

Vor der Auswertung des Graphen wird das zu identifizierende Artefakt mit den Mustern aus \autoref{subsec:erkennung-typspezifische-artefakte} abgeglichen, um typspezifische Informationen für den Abgleich der Artefakt-Selektoren der Knoten zu erhalten.
Diese programmatisch ermittelten Attribute sichern, dass Attributwertprüfungen schärfer, zuverlässiger und atomarer durchgeführt werden können.

\paragraph{Artefakt-Selektor}

Jeder Artefakt-Knoten enthält eine Liste an Selektoren, die durch ein logisches ODER verbunden werden, damit nur ein Selektor zutreffen muss, um ein Artefakt zu identifizieren.
Das ermöglicht es, mehrere alternativen aufzuführen, wie sich ein reales Artefakt in seiner Attributmenge ausprägen kann und verhindert die Notwendigkeit, einen zweiten Knoten für dasselbe Artefakt anlegen zu müssen.

Jeder Selektor besteht aus einer Menge an Attributen, von denen alle für ein Artefakt mit einem logischen UND übereinstimmen müssen, um den Eintrag zu aktivieren.
Um \hyperref[subsec:req-multiple-attribute-values]{A-08} zu erfüllen, sind die Werte der abzugleichenden Attribute als Listen an möglichen Werten abgelegt, die mit einem weiteren logischen ODER verbunden sind, also von denen nur ein Wert zutreffen muss.
Zudem können die Werte nach \hyperref[subsec:req-regex-support]{A-09} das bisherige inkrementelle Wildcard-System verwenden, um möglichst alle Matching-Fälle abzudecken.
Die abfragbaren Attribute sind in zwei Mengen geteilt, die sich in ihrer Quellen unterscheiden.

Rohe Artefakt-Attribute beziehen sich auf die Attribute, die das Artefakt direkt in sich speichert.
Im alten System war diese Menge die einzige, die abgefragt werden konnte.
Häufig verwendete Attribute sind \texttt{Id}, \texttt{Type} und Ökosystemspezifische wie \texttt{Group Id}.
Da diese Art von Abfrage in dem neuen Format aufgrund ihrer Instabilität, der Unschärfe wegen der Kombination von mehreren Werten in einem Attribut und der anderen Herausforderungen auf Artefakt-Attributen in den Hintergrund treten soll, werden diese Abfragen explizit als solche gekennzeichnet werden müssen.

Die neuen typspezifischen Attribute werden von den in \autoref{subsubsec:model-graph-knoten} aufgelisteten Extraktoren aufbereitet und in den Selektoren als First-Class Attribute zur Verfügung gestellt.
Die Standard-Attribute sind \texttt{type} zur Auswahl eines erkannten Artefakttyps, \texttt{name} für einen ökosystemspezifischen Paketnamen und \texttt{version} für die Version.
Basierend auf dem \texttt{type}-Wert wird in dem Objekt die Präsenz weiterer Attribute der typisierten Artefakte zugesichert und für Abgleiche exponiert.

\paragraph{Vererbung von Selektoren}

Wie in \autoref{subsubsec:model-edges-relations} angerissen haben Artefakt-Knoten die Möglichkeit, sich mit einer Vererbungskante auf weitere Artefakt-Knoten zu beziehen.
Eine solche Beziehung bedeutet, dass der Knoten, von dem geerbt wird, ebenfalls mit seinen Selektoren auf das aktuell zu prüfende Artefakt erfolgreich übereinstimmen muss.
Diese Beziehung kann verkettet werden, indem von dem geerbten Knoten eine weitere Vererbungskante losgeht.
Auf diese Weise können beliebig viele Identifikationen aufeinander folgen.

Dies führt zu einer weiteren Herausforderung in der Identifikationslogik, da nach \hyperref[subsec:req-graph-inner-consistency]{A-19} immer nur genau ein Knotenpunkt für eine zu identifizierende Repräsentation gefunden werden darf.
Da die allgemeineren Knotenpunkte, von denen die spezifischen Ausprägungen der Artefakt-Knoten erben, bei einem Artefakt welche den spezifischen Knoten selektieren immer auch mit den Selektoren des allgemeinen Knotens übereinstimmen werden, muss eine Ausschlusslogik implementiert werden.
Da immer die spezifischste Identifikation für die Repräsentation gewählt werden soll, wird auf der Ergebnismenge der gefundenen Knoten die Hierarchie der Vererbung ausgewertet und alle entfernt, von denen geerbt wird.

\paragraph{Ergebnisse der Selektion}

Das Ergebnis des Selektionsprozesses ist im optimalen Fall ein einziger \texttt{artifact}-Knoten im Graphen, dem das eingehende Software-Artefakt entspricht.
Es lässt sich jedoch aufgrund eines ungünstig strukturierten Graphen nicht ausschließen, dass doch eine Menge an Knoten identifiziert wird.
Da der restliche Ablauf des Prozesses den Graphen auf ein Artefakt anzuwenden jedoch pro Knotenpunkt getrennt durchgeführt wird, macht dies für die restliche Beschreibung keinen Unterschied.
Dieser (bzw.\ diese) gefundene(n) Knoten dienen als Ausgangspunkt für die anschließende Durchquerung des Graphen (\autoref{subsubsec:model-traversal}), um die zugehörigen Repräsentationen zu ermitteln.

\subsubsection{Durchquerung des Graphen}\label{subsubsec:model-traversal}
% Auswertungslogik für Relationen und Versionstransformation

Nachdem ein eingehendes Artefakt erfolgreich einem \texttt{artifact}-Knoten im Graphen zugeordnet wurde, beginnt die Phase der Graphen-Durchquerung.
In der Traversierung des Graphen von dem Startknoten zu den Zielknoten werden entlang der Kanten und Knoten zugehörige Metainformationen aggregiert, die dann in der anschließenden Auswertungsphase interpretiert werden.
In diesem Prozess werden Kanten der Repräsentationsbeziehungen \enquote{is} und \enquote{is not} unterschiedlich behandelt als die Vererbungsbeziehungen vom Typ \enquote{inherit}.

Der erste Pfad folgt allgemein den Repräsentationsbeziehungen, die zunächst vom Artefakt-Knoten und später von allen weiteren erreichbaren Knoten ausgehen.
Diesen Beziehungen wird allgemein immer gefolgt, egal ob es eine positive oder negative Relation ist.
Falls es sich jedoch um eine negative Relation handelt, werden alle auf diesem Pfad durch den Graphen nachfolgenden Kanten ebenfalls als \enquote{is not} behandelt, was den späteren Anwendungsschritt beeinflusst.
Jede Kante stellt zudem optional Transformationsregeln bereit, die bei der Traversierung je durchquertem Pfad zunächst einmal einfach alle eingesammelt werden.
Erreichte Produktknoten enthalten ebenfalls optional Transformationsregeln, die nur dann mit in die Liste an Transformationen eingesammelt werden, wenn der ursprüngliche Quellknoten teil des Namensraums ist, unter dem diese Transformation abgelegt ist.
Die konkrete Anwendbarkeit basierend auf Quell- und Zielknoteneigenschaften wird erst im nächsten Schritt ausgewertet, wenn die Zielknoten alle gesammelt wurden.

Der zweite Pfad wertet Vererbungshierarchien zwischen Knoten aus.
Vererbungshierarchien bei Artefakt-Knoten werden ausschließlich zum Teilen der Selektoren in dem initialen Identifikationsprozess verwendet.
Daher werden hier ausschließlich die Vererbungskanten zwischen Produkt-Knoten ausgewertet.
Allgemein funktioniert das folgen der Vererbungskanten identisch wie die regulären Repräsentationsbeziehungen, mit dem Unterschied, dass nur die spezifischsten Kanten auf einen zwischen Vererbungsebenen geteilten Knoten behalten werden.
Dies wird dadurch ermöglicht, indem zunächst über die Auswertung der allgemeinen Knoten die allgemeineren Kanten zum Erreichen eines Knotens gespeichert werden und die spezialisierten Knoten später diese Kanten mit ihren eigenen überschreiben werden.

Während der rekursiven Durchquerung sollte das System einen Kontextzustand mit Informationen über den aktuellen Pfad durch den Graphen verwalten.
Die Informationen, die er verwaltet, sind der aktuellen Knoten, die Beziehung die zum Erreichen dieses verwendet wurde, der gesamte bisherige Pfad zur Vermeidung von Schleifen, und die gesammelten Transformationsanweisungen.

Die Gesamtheit der gesammelten Kontextzustände ist das Ergebnis dieser Phase und die Eingabe für die finale Anwendung der Zielknoten.
Jeder Kontext stellt dabei einen Zielknoten dar, mit dem vollständigen Pfad der Entscheidungsfindung und den Transformationen.

\subsubsection{Anwendung von zutreffenden Knotenpunkten auf Artefakte}\label{subsubsec:model-result-processing-apply-nodes-to-artifact}

Die identifizierten Zielknoten werden abschließend einzeln auf das Artefakt angewendet.
Dabei werden je Knoten zudem die erreichende Kante und die gesammelten Transformationen entlang des Pfades übergeben.

Zunächst werden die gesammelten Transformationen auf ihre Anwendbarkeit gefiltert.
Der Namensraum-Filter wurde bereits während dem letzten Schritt der Traversierung berücksichtigt, sodass nun die Quellartefakt- und Zielknotenfilter aus \autoref{subsubsec:model-graph-knoten} angewendet werden.
Die erste Prüfung ist die Existenz einer Transformation mit dem \texttt{discard}-Attribut, hier wird der Knoten vollständig von der Identifikation verworfen.
Ein weiteres Transformationsattribut kann den Typ der eingehenden Kante auf einen anderen (z.\ B. \enquote{is not}) überschreiben.

Die verbleibenden Transformationen modifizieren die Knotendaten mit typspezifischen Attributen.
Die restlichen Transformationsattribute werden an den Zielknoten übergeben, um typspezifische Änderungen an den anzuwendenden Daten vorzunehmen, bevor sie auf das Artefakt angewendet werden.
So wird beispielsweise bei \acrshort{cpe}-Repräsentationen die \acrshort{cpe} in ihre Komponenten zerlegt, die dann durch Transformationen auf konkrete Werte gesetzt werden können (z.B. \texttt{vendor} oder \texttt{version}).
Die modifizierten Komponenten werden dann wieder zu einer gültigen \acrshort{cpe} kombiniert.
Andere Repräsentationstypen folgen ähnlichen Mustern mit eigenen typspezifischen Attributen.

Die transformierten Knoten werden abschließend unter Berücksichtigung des effektiven Kantentyps auf das Subjekt, dem Artefakt, angewandt.
Bei \acrshort{cpe}-Knoten führt eine \enquote{is}-Beziehung zum Hinzufügen der \acrshort{cpe} zu \texttt{Additional CPE URIs} und dem Entfernen aus \texttt{Inapplicable CPE URIs}, wobei \enquote{is not} entsprechend das umgekehrte bewirkt.
Dies verhindert implizit Widersprüche durch gegensätzliche Klassifizierungen einer \acrshort{cpe} und löst eine der Herausforderungen von \hyperref[subsec:c-10-order-dependency]{C-10}.
