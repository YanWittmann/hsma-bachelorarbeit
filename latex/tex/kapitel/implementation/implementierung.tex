\section{Implementierung und Integration}\label{sec:implementierung}

Das in \autoref{sec:model-modellierungsansatz} entworfene Modell des neuen Korrelationssystems sollte als Teil der Arbeit als Nachweis für die Realisierbarkeit als Java-Applikation in das bestehende Code-Repository implementiert werden.
Dazu werden zunächst die technischen und architekturellen Entscheidungen aufgeführt, dann die Implementierung vorgestellt.

\subsection{Technische Grundentscheidungen}\label{subsec:impl-tech-choices}

Bei der Implementierung des neuen Korrelationssystems wurden mehrere technische Grundentscheidungen aus den Anforderungen und Rahmenbedingungen des Projekt- und Firmenkontexts getroffen, auf denen das Modell implementiert werden soll.

\paragraph{Programmiersprache}

Als Programmiersprache wurde Java in der Version 8 gewählt.
Dies stellt sicher, dass sich das neue Korrelationssystem in das bestehende Schwachstellenmanagement der \metaeffektsp integrieren lässt, welches ebenfalls auf dieser Technologie basiert.
Das Ökosystem von Java bietet zudem eine umfangreiche Liste an Bibliotheken über das Repository von Maven Central\footnote{\url{https://search.maven.org}} für alle Nutzungskontexte und das robuste Typsystem mit Unterstützung für Generics wird die Entwicklung der Datenstrukturen für den Korrelationsgraphen vereinfachen.

\paragraph{Datenbanktechnologie}

Für die persistente Speicherung des Korrelationsgraphen wurde SQLite\footnote{\url{https://sqlite.org}} als relationale Datenbank gewählt.
Diese serverlose, dateibasierte relationale Datenbank vereinfacht die Verwaltung, Sicherung und Auslieferung erheblich, was insbesondere den Einsatz auf Kundenseite erleichtert.

Als relationale Datenbank muss von Anfang an ein einheitliches Schema für die Tabellen definiert werden.
Die Kernattribute der Datenelemente werden als dedizierte Attribute in den Spalten der Tabellen abgelegt.
Um aber für zukünftige Formatänderungen vorzusorgen, und um die stark typabhängigen zusätzlichen Attribute in den Spalten vernünftig zur Serialisierung und Deserialisierung abspeichern zu können, wird einfach das gesamte Datenobjekt als \acrfullr{json}-Objekt in einer zusätzlichen Spalte abgelegt und bei Bedarf ausgelesen.
Das ermöglicht eine flexible Erweiterung der Attribute ohne Schemaänderungen und dank Funktionen wie \texttt{json\_extract}\footnote{\url{https://sqlite.org/json1.html}} von SQLite kann dennoch bei Bedarf auf Attribute in den Objekten über \acrfullr{sql} zugegriffen.

Alternativen, die in Betracht gezogen wurden, sind:

\begin{itemize}
    \itemsep0em
    \item Ein Lucene-Index\footnote{\url{https://lucene.apache.org}}, da Apache Lucene bereits im Projektumfeld für die performante Speicherung anderer Schwachstellendaten genutzt wird und eine sehr schnelle Volltextsuche auf strukturierter und unstrukturierten Information erlaubt.
    Jedoch wäre nicht nur das Verteilen der Datenbank komplizierter, da es sich um einen Ordner an Dateien handelt der zunächst komprimiert und entkomprimiert werden müsste, sondern auch das iterative Arbeiten mit dem Index wäre schwerer, da bei diesem nicht einfach eine Datei als Backup verwendet werden könnte, die die Arbeitsversion einfach überschreiben könnte, sondern ein ganzer Ordner ersetzt werden muss.
    \item Die direkte Speicherung der Daten als \acrshort{json}-Dateien auf dem Dateisystem wurde ebenfalls in Betracht gezogen.
    Dieser Ansatz hat in seiner Einfachheit Vorteile, da er keine zusätzlichen Treiber oder Bibliotheken erfordert.
    Er wurde jedoch verworfen, da er keine effizienten Abfragemechanismen bietet, was die Skalierbarkeit einschränkt und zudem keine automatisierten Garantien für die Datenintegrität bestehen.
    \item Der Einsatz einer dokumentenorientierten NoSQL Datenbank wie MongoDB\footnote{\url{https://www.mongodb.com}}, welche native JSON-Speicherung und flexible Schemata bietet.
    Aufgrund des Overheads durch eine zusätzliche Serverkomponente und Lizenzüberlegungen wurde diese Lösung nicht weiterverfolgt.
\end{itemize}

\paragraph{Bibliotheken und Frameworks}

Für die Implementierung wurden verschiedene Bibliotheken eingesetzt, um die Entwicklung zu beschleunigen:

\begin{itemize}
    \itemsep0em
    \item Gson\footnote{\url{https://github.com/google/gson}}: Für die \acrshort{json}-Serialisierung und -Deserialisierung der Knoten- und Kantendaten.
    \item Guava\footnote{\url{https://github.com/google/guava}}: Bietet erweiterte Datenstrukturen und Hilfsmethoden, vor allem für das Caching von Abfrageergebnissen.
    \item Apache Commons\footnote{\url{https://commons.apache.org}}: Stellt Hilfsfunktionen für die Datei- und Stringverarbeitung bereit.
    \item Lombok\footnote{\url{https://projectlombok.org}}: Reduziert Boilerplate-Code durch Annotation-basierte Codegenerierung für Getter, Setter und weitere Methoden.
    \item Für die Verarbeitung von diversen Datentypen wurden spezialisierte Bibliotheken integriert, wie die Bibliothek \texttt{us.springett.parsers.cpe}\footnote{\url{https://github.com/stevespringett/cpe-parser}} um \acrshort{cpe}-Strings zu verarbeiten.
\end{itemize}

\subsection{Architekturübersicht und Implementierung}\label{subsec:impl-arch-overview}

Das Korrelationssystem wird über mehrere Klassen implementiert, um die Erstellung, Verwaltung und Abfrage des Graphen zu ermöglichen.
Um Namenskonflikte zwischen anderen Modulen zu vermeiden und um ein einheitliches Namensschema zu definieren, werden alle relevanten Klassen mit \enquote{Rep} als Präfix gekennzeichnet.

\subsubsection{Kernkomponenten}

Die in dieser Sektion beschriebenen Klassen sind in dem Klassendiagramm in \autoref{fig:impl-class-diagram-core-model} dargestellt.

\begin{figure}[htbp]
    \centering
    \makebox[\textwidth]{\includesvg[width=1.3\textwidth, inkscapelatex=false]{bilder/impl-class-diagram-core-model}}
    \caption{Klassendiagramm der Kernkomponenten}
    \label{fig:impl-class-diagram-core-model}
\end{figure}

Die zentrale Klasse \texttt{RepGraph} repräsentiert den Korrelationsgraphen und bietet Methoden zum Zugriff auf Knoten und Kanten.
Sie verwaltet über eine Klasse \texttt{DbConnectionProvider} die Datenbankverbindung, stellt sicher, dass die Verbindung korrekt initialisiert und verwaltet wird und führt die SQL-Operationen aus, die für die Graphmanipulation erforderlich sind.
Die Klasse implementiert auch Methoden zur Sicherung und Wiederherstellung von Backups des Graphen.

Um eine klare Trennung der Manipulation des Graphen und der Abfragelogik zu haben, wird eine Klasse \texttt{RepGraphQuery} eingeführt, die Methoden zur Traversierung und Filterung des Graphen bereitstellt.
Die Klasse nutzt das \enquote{Weak References}-Feature der Caching-Mechanismen die Guava bereitstellt, um die Leistung bei wiederholten Abfragen zu verbessern und trotzdem vom Java Garbage Collector profitiert, um nicht erreichbare Instanzen aufzuräumen \autocite{GuavaCachesExplained}.

Das Knotenmodell wird durch eine Hierarchie von Klassen repräsentiert, die von der abstrakten Basisklasse \texttt{RepGraphNode} abgeleitet werden.
Jeder Knotentyp (\acrshort{cpe}, \acrshort{purl}, Artefakt, Produkt usw.) wird durch eine spezialisierte Klasse implementiert, die die spezifischen Attribute und Verhaltensweisen des jeweiligen Typs kapselt.
Die Klasse \texttt{RepCpeNode} beispielsweise implementiert die Logik für \acrshort{cpe}-Knoten, einschließlich der Verarbeitung von CPE-Strings und der Anwendung von Transformationen.
Ähnlich implementiert \texttt{RepArtifactNode} die Logik für Artefaktknoten, einschließlich der Matching-Algorithmen für die Identifikation von Artefakten.

Um die programmatische Traversierung des Graphen für Abfragen für die Verwendung möglichst ausdrucksstark gestalten zu können, hält jeder Knoten eine Liste der von ihm ausgehenden Kanten samt ihrer Zielknoten als Attribut bereit.
Diese Liste wird mittels Lazy Loading erst bei dem ersten Zugriff befüllt, um zu verhindern, dass große Inseln des Graphen unnötig geladen werden.
Die Verwendung eines Caches für die Instanziierung von Knoten und Kanten stellt zudem sicher, dass bei zyklischen Verbindungen oder wiederholten Zugriffen kein zusätzliches Laden von Daten erforderlich ist und für jeden Knoten nur eine einzige wiederverwendbare Objektinstanz existiert.
Der Datenzugriff erfolgt in zwei Modi: \enquote{Read-Only} und \enquote{Read/Write}, wobei der Cache nur im Lesemodus aktiv ist, um zu garantieren, dass Abfragen im Schreibmodus stets den aktuellen Datenstand aus der Datenbank widerspiegeln.

Kanten werden durch die Klasse \texttt{RepGraphEdge} repräsentiert, die Informationen über Quell- und Zielknoten und Beziehungstyp, sowie Metadaten enthält.
Die Klasse implementiert auch die Logik für die Anwendung von Transformationen, die entlang der Kanten propagiert werden.

% Über diese Liste an Referenzen zu anderen Knoten können nun beliebige komplexe Abfragen gebaut werden.

\subsubsection{Datenbankschema}

Zum Programmstart wird sichergestellt, dass die Datenbank die nötigen Tabellen, Spalten und Indizes enthält.
Das \acrshort{sql}-Skript mit dem entsprechenden Schema kann in \autoref{lst:create-node-table-sql} gefunden werden.
Neben den vollständig als \acrshort{json} serialisierten Datenobjekten enthält die \texttt{nodes}-Tabelle die Knoten mit einer eindeutigen Id und einem Knotentyp und die \texttt{edges}-Tabelle Kanten mit Quell- und Zielknoten-Ids, Richtung, Beziehungstyp.

\lstinputlisting[
    firstline=1,
    language=SQL,
    caption={Datenbankschema aus \texttt{create-node-table.sql}},
    label=lst:create-node-table-sql,
    basicstyle=\ttfamily\scriptsize
]{code/create-node-table.sql}

\subsubsection{Modifikationssystem}

Das Modifikationssystem ermöglicht die Änderung des Graphen durch verschiedene Quellen, sei es automatisiert oder auch manuell.
Die zuständigen Klassen sind im Klassendiagramm in \autoref{fig:impl-class-diagram-modifiers} zu finden.

\begin{figure}[htbp]
    \centering
    \makebox[\textwidth]{\includesvg[width=1\textwidth, inkscapelatex=false]{bilder/impl-class-diagram-modifiers}}
    \caption{Klassendiagramm der Modifikationsklassen}
    \label{fig:impl-class-diagram-modifiers}
\end{figure}

Die Klasse \texttt{RepGraphModifierEntry} ist die Basisklasse für Modifikationsanweisungen und ist dafür verantwortlich, sie auf den Graphen anzuwenden.
Wie in \autoref{subsec:model-graph-modification} beschrieben, unterstützt sie mit den verschiedenen Modi die Erwartungshaltung an den Graphen auszudrücken und arbeitet allgemein inkrementell auf den Daten.
Um eine Menge an Modifikationseinträgen auf den Graphen anzuwenden wird das System in zwei Phasen aufgeteilt und wird anhand vom Pseudocode in \autoref{lst:modifikation-pseudocode} erklärt.

In der ersten Phase wird für jeden Eintrag der Graph nach dem Knoten mit dem eindeutigen Typ und Id-Paar durchsucht, um je nach \texttt{ModificationType} das Prüfen der Knotenexistenz durchzuführen und den Knoten optional anzulegen.
Diese erste Phase sorgt dafür, dass alle referenzierten Knoten instanziiert sind, sodass in der nächsten Phase die Relationen zwischen diesen korrekt aufgebaut werden können.
In der zweiten Phase werden die Knotenattribute und Kanten in drei getrennten Schritten befüllt.
Zunächst werden in \texttt{baseModification} einige Basisattribute ausgewertet, die für alle Knotentypen gültig sind, wie Namensräume und Metadaten.
Die Methode \texttt{processRelations} verarbeitet dann alle konfigurierten Relationen.
Schließlich wird die \texttt{implementationSpecificModification} ausgeführt, in der je nach Knotentyp weitere Attribute aufgefüllt werden und dann wird der aktualisierte Knoten mit \texttt{graph.insertOrUpdateNode} persistiert.

\begin{lstlisting}[language=pseudo,caption={Ablauf des Modifikationssystems für eine Menge an Modifikationen},label=lst:modifikation-pseudocode,basicstyle=\ttfamily\scriptsize]
FOR EACH entry IN entries DO
    node := graph.findNode(entry.nodeType, entry.nodeId)
    IF entry.mode == CREATE AND node EXISTS THEN
        THROW "Node exists"
    ELSE IF (entry.mode == RESET OR APPEND) AND node DOES NOT EXIST THEN
        THROW "Node missing"
    END IF
    graph.ensureExists(entry)
END FOR

FOR EACH entry IN entries DO
    node := graph.findNode(entry.nodeType, entry.nodeId)
    entry.baseModification(graph, node)
    entry.processRelations(graph, node)
    entry.implementationSpecificModification(graph, node)
    graph.insertOrUpdateNode(node, (old, new) --> new)
END FOR
\end{lstlisting}

\paragraph{RepContributor}

Die abstrakte Klasse \texttt{RepContributor} definiert über einen einheitlichen Mechanismus die Struktur für verschiedene Datenquellen, die Daten zum Korrelationsgraphen beitragen wollen.
Die meisten Implementierungen dieser Klasse repräsentieren automatisierte Prozesse, die \acrshortpl{vdb} oder weitere Datenquellen auswerten, um daraus Korrelationsinformationen abzuleiten.
Eine dedizierte Implementierung ist jedoch für die Verarbeitung des manuellen \acrshort{yaml}-Formats und dessen Anwendung auf den Graphen zuständig.
Dieser manuelle Contributor ist der letzte, der ausgeführt wird, um sicherzustellen, dass alle vorherigen Contributors durch den manuellen korrigiert werden können.

Auch wenn jede Implementierung sich auf andere Daten- und Knotentypen bezieht, funktionieren alle nach demselben Muster:
Zunächst wird die entsprechende Datenquelle analysiert, um die betreffenden Datenobjekte zu finden, die als Knoten repräsentiert werden sollen.
Mit diesen werden programmatisch Modifikatoren für den Graphen zusammengestellt und erst ganz zum Schluss wird die Methode aufgerufen, die die Modifikationen einheitlich auf den Graphen anwendet.

Ein Beispiel ist der \texttt{CpeDictionaryRepContributor}, der als erster Contributor das offizielle \acrshort{cpe}-Dictionary des \acrshort{nist} vollständig importiert, um alle \acrshort{cpe}-Knoten mit ihren Metadaten einzufügen.
Diese Klasse durchsucht den \acrshort{cpe}-Index nach Vendor-Produkt-Paaren und extrahiert die zugehörigen Metadaten wie Titel und Beschreibungen, um sie als Knoten im Graphen anzulegen.

Mithilfe des \texttt{RepGraphModifierParser}, der für das rekursive Einlesen von \acrshort{yaml}-Dateien zuständig ist, wird der \texttt{FileRepContributor} implementiert.
Er konvertiert die \acrshort{yaml}-Struktur in \texttt{RepGraphModifierEntry}-Objekte, die dann auf den Graphen angewendet werden können.
Fehler beim Parsing werden mit aussagekräftigen Meldungen mit Referenzen auf die originale Datei und die Zeile des Eintrags in der Datei protokolliert, um die Fehlersuche zu erleichtern.

\subsubsection{Artefakt-Typ-Erkennung}\label{subsubsec:impl-artifact-type-detection}

Um die Art eines Artefakts automatisch zu bestimmen, wird die Klasse \texttt{RepTypedArtifact} verwendet, die als Wrapper über einem generischen Artefakt liegt und dessen Typisierung kapselt.
Instanzen dieser Klasse werden als Ausgangslage für die Verarbeitung von Artefakten, bei z.\,B. den Matching-Algorithmen oder für die bedingte Anwendung von Transformationen auf Kanten.
\autoref{fig:impl-class-diagram-typed-artifacts} zeigt das zugrunde liegende Klassendiagramm der Typ-Erkennung.

Die Typisierung erfolgt durch eine statische Factory-Methode und basiert nicht auf den definierten Knotentypen, sondern einem weiteren generischen Typsystem, um das System in weiteren Kontexten wiederverwenden zu können.
Damit kann die Typisierung unabhängig von dem Korrelationssystem entwickelt, getestet und eingesetzt werden.
Der Pseudocode in \autoref{lst:artifact-typing-code} zeigt die Entscheidungslogik zur Typauswahl.

Die Erkennung basiert auf den Attributkombinationen, die in \autoref{subsec:erkennung-typspezifische-artefakte} aufgeführt werden.
Wenn kein bekannter Typ ermittelt werden kann, fällt die Erkennung auf \texttt{GenericTypedArtifact} zurück, in dem keine spezialisierte Verarbeitung geschieht.

Ein Beispiel ist die Klasse \texttt{JavaTypedArtifact}, die Artefakte mit Bezug zum Java-Ökosystem erkennt, und erweiterte Informationen aus diesen extrahiert.
Falls vorhanden, wird die \acrshort{purl} auf dem Artefakt verwendet, um die Koordinatenbestandteile \texttt{groupId}, \texttt{artifactId} und \texttt{version} zu erhalten.
Fehlende Informationen werden aus den verbleibenden Attributen heuristisch ergänzt, wie die Analyse des Dateinamens, um eine plausible \texttt{groupId} oder \texttt{artifactId} zu rekonstruieren, falls diese nicht explizit angegeben ist.
Zudem werden qualifizierte Bezeichner innerhalb der \texttt{artifactId} bereinigt, um durch fehlerhafte Eingaben in das System wie Namensdopplungen (\enquote{io.quarkus.quarkus-vertx-deployment} zu \enquote{quarkus-vertx-deployment}) zu vermeiden.
Diese Logik kann so ein einziges Mal in Code implementiert werden, statt auf jede Kombination im Graphen prüfen zu müssen.

\begin{figure}[htbp]
    \centering
    \makebox[\textwidth]{\includesvg[width=1.3\textwidth, inkscapelatex=false]{bilder/impl-class-diagram-typed-artifacts}}
    \caption{Klassendiagramm der Artefakt-Typ-Erkennung}
    \label{fig:impl-class-diagram-typed-artifacts}
\end{figure}

\begin{lstlisting}[language=pseudo,caption={Typisierung eines Artefakts basierend auf Attributen},label=lst:artifact-typing-code,basicstyle=\ttfamily\scriptsize]
id            := LOWERCASE(artifact.Id)
type          := artifact.Type
specificType := artifact.SpecificType
ecosystem     := artifact.Ecosystem

IF type == "file" OR FILE_EXTENSION(artifact.id) IN otherFileExtensions THEN
    RETURN OtherFileTypedArtifact(artifact)
END IF

IF specificType == "jar-module" OR ecosystem == "maven" OR id.endsWith(".jar") THEN
    RETURN JavaTypedArtifact(artifact)
END IF

IF type == "python-module" THEN
    RETURN PythonModuleTypedArtifact(artifact)
END IF

IF type == "operating system" THEN
    RETURN OperatingSystemTypedArtifact(artifact)
END IF

IF type IN ["web-module", "npm-module", "nodejs-module"] OR specificType == "npm-module" THEN
    RETURN NpmTypedArtifact(artifact)
END IF

IF specificType == "java-runtime" THEN
    RETURN JavaRuntimeTypeArtifact(artifact)
ELSE IF (id CONTAINS "jdk" OR id CONTAINS "jre") AND isEmpty(artifact.GroupId) THEN
    RETURN JavaRuntimeTypeArtifact(artifact)
END IF

IF type == "package" OR ecosystem IN linuxPurlTypes THEN
    RETURN LinuxTypedArtifact(artifact)
END IF

RETURN GenericTypedArtifact(artifact)
\end{lstlisting}

\subsubsection{Artefakt-Matching}

Die Implementierung des Artefakt-Matchings erfolgt über die Klasse \texttt{RepArtifactMatcher}, die verschiedene Strategien für den Abgleich von Artefakten mit Knotenpunkten im Graphen bereitstellt.
Jeder \texttt{RepArtifactNode}-Knotenpunkt enthält eine Liste von Instanzen dieser Klasse, die mit einem logischen ODER verbunden sind.
Die in \autoref{subsubsec:model-matching} beschriebene Typ-Erkennung ist die Grundlage der Erkennung.

Die Klasse \texttt{RepFieldMatcher} ist der Ersatz für das bisherige System des Wildcard-Abgleichs.
Eine Herausforderung des alten Wildcard-Systems bestand darin, dass der zu prüfende Wert als generisches \texttt{Object} in der Datenstruktur der Selektoren gespeichert wurde.
Dieses konnte als Wert entweder einen Text oder ein kompiliertes \texttt{Pattern} annehmen.
Dies erforderte ständige Typüberprüfungen und Typumwandlungen (Casts).
Zudem konnte der ursprüngliche Wildcard-String nach der Transformation und Kompilierung durch das inkrementelle Wildcard-System nicht mehr zuverlässig rekonstruiert werden.
Im neuen System werden die unveränderten Quellmuster also neben den transformierten Patterns abgelegt und bei der Serialisierung in den Graphen wird immer nur das Quellmuster verwendet.

Der Selektor prüft alle konfigurierten Attribute, wobei die Logik für UND- und ODER-Verknüpfungen wie im Modell beschrieben umgesetzt werden.
Um die typspezifischen Attribute der Knoten prüfen zu können, stellt das \texttt{TypedArtifact} eine Methode \texttt{buildTypeSpecificAttributes()} bereit, mit der auf eine Menge an benannten Eigenschaften zugegriffen werden kann.

\subsubsection{Traversierung}

Um die Traversierung des Graphen möglichst einfach zu gestalten, wird in der \texttt{TraversalQuery}-Klasse eine fluent \acrshort{api} für die Definition von Traversierungsregeln bereitgestellt.
Mit Methoden wie \texttt{outgoing()}, \texttt{incoming()} und \texttt{undirected()} kann die Richtung der Traversierung gesteuert werden.
Zusätzlich können Filter für Knotentypen (\texttt{targetNodeType(type)}), Beziehungstypen (\texttt{relationshipType(type)}) und benutzerdefinierte Prädikate für Knoten und Kanten genutzt werden.
Die Abfragen können wiederverwendet werden und die am häufigsten eingesetzten werden als statische Konstanten definiert.

Um die Abfragen direkt an einen Knotenpunkt stellen zu können, enthält jeder Knoten eine Referenz auf das \texttt{RepGraph}-Objekt in dem er liegt.
Da in dem System häufig mehrere Abfragen auf einen selben Knotenpunkt gemacht werden, merkt sich ein Knoten beim ersten Zugriff seine erreichbaren Knoten und Kanten, um diese bei der nächsten Anfrage einfach zugänglich zu machen.

Die Ergebnisse einer Traversierung werden in der \texttt{TraversalResult}-Klasse gekapselt, um auf die gefundenen Knoten und die dabei verwendeten Kanten zuzugreifen.
Ein Beispiel für den Zugriff ist in \autoref{lst:graph-traversal-code} zu finden.

\begin{lstlisting}[language=Java,caption={Traversierungsabfragen in Java},label=lst:graph-traversal-code,basicstyle=\ttfamily\scriptsize]
RepGraphQuery.TraversalQuery query = traversalQuery()
    .outgoing()
    .relationshipType(RelationshipType.INHERITANCE)
    .targetNodeType(RepArtifactNode.class);

for (RepGraphQuery.TraversalResultEntry entry : currentNode.traverse(query)) {
    RepGraphNode node = (RepArtifactNode) entry.getNode();
    RepGraphEdge edge = entry.getEdge();
}
\end{lstlisting}

\subsection{Anwendung auf Artefakte}\label{subsec:impl-apply-to-artifacts}

Die in \autoref{subsec:model-apply-to-artifact} beschriebenen Schritte das neue Korrelationssystem auf ein Artefakt anzuwenden werden im Folgenden anhand der Code-Implementierung erklärt.
Der erste Schritt der Artefakt-Typ-Erkennung wurde bereits in \autoref{subsubsec:impl-artifact-type-detection} gezeigt.

\subsubsection{Durchsuchung des Graphen nach anwendbaren Artefakt-Knoten}

Die Verarbeitung eines Artefakts beginnt mit der Erstellung einer Instanz eines \texttt{RepTypedArtifact}, wie in \autoref{subsubsec:impl-artifact-type-detection} beschrieben.
Auf dieser Basis kann nun der Matching-Prozess gestartet werden.

\autoref{lst:impl-findMatchingNodes} zeigt mit der Methode \texttt{findMatchingNodes} den Einstiegspunkt, der zur Identifikation von Knoten im Repräsentationsgraphen dient.
Diese nimmt ein typisiertes Artefakt entgegen und erstellt zunächst eine leere Ergebnismenge \texttt{matches}.
Anschließend wird mit der Hilfsmethode \texttt{processNodesByType} über alle Knoten eines bestimmten Typs, hier \texttt{artifact}, im Graphen zu iterieren.
Um nicht alle Knoteninstanzen gleichzeitig im Speicher lagern zu müssen, wird statt einem Rückgabewert vom Typ \texttt{List<N>} eher ein Ansatz mit einem \texttt{Consumer} gewählt, der über einen Lambda-Ausdruck in der ursprünglichen Methode beliebige Aktionen auf den Knoten ausführen kann.

Für jeden dieser Artefakt-Knoten wird dann überprüft, ob er mit dem gegebenen Artefakt übereinstimmt.
In diesem ersten Schritt werden alle Vererbungsregeln ignoriert, da bei der Vererbung von Artefakt-Knoten bereits vom Konzept her beabsichtigt jeder Knoten in der Vererbungshierarchie mit einem seiner Selektoren zutreffen muss, um die darüberliegenden zu ermöglichen.
Dies geschieht mittels der Methode \texttt{matchIdentification}, die über alle Selektoren in dem Knoten iteriert und den ersten erfolgreichen Vergleich als Instanz zurückgibt.
Liefert diese Methode ein nicht-\texttt{null}-Ergebnis, ist der Knoten ein Treffer und wird zur Menge \texttt{matches} hinzugefügt.

\begin{lstlisting}[language=Java,caption={Methoden \texttt{findMatchingNodes} und \texttt{processNodesByType}},label=lst:impl-findMatchingNodes,basicstyle=\ttfamily\scriptsize]
public Set<RepGraphNode> findMatchingNodes(TypedArtifact artifact) {
    Set<RepGraphNode> matches = new HashSet<>();
    processNodesByType(RepArtifactNode.TYPE, RepArtifactNode.class, node -> {
        if (node.matchIdentification(artifact) != null) {
            matches.add(node);
        }
    });
    return filterByInheritance(matches, null);
}

public <N extends RepGraphNode> void processNodesByType(String type, Class<N> clazz, Consumer<N> nodeConsumer) {
    try (QueryResult qr = graph.executeQuery("SELECT * FROM nodes WHERE nodeType = ?", type)) {
        dataConstructor.processNodes(qr.resultSet, node -> nodeConsumer.accept(clazz.cast(node)));
    }
}
\end{lstlisting}

Nachdem die initialen Übereinstimmungen gefunden wurden, erfolgt in einem zweiten Schritt die Anwendung einer Vererbungslogik über die Methode \texttt{filterByInheritance}, wie in \autoref{lst:impl-filterByInheritance} zu sehen.
Diese dient dazu, Vererbungshierarchien auszuwerten und Knoten aus der Hierarchie zu entfernen, sofern auch eine direkt spezifischere Variante des Knotens gefunden wurde.

Zunächst wird über eine Traversierung des Graphen entlang der definierten Vererbungskanten eine Zuordnung aufgebaut, in der jedem der identifizierten Knoten die Menge seiner unmittelbaren Vererbungsbasen gegenübergestellt wird.
Dann wird über alle Eingabeknoten iteriert, um zu prüfen, ob sich innerhalb ihrer jeweiligen Vererbungshierarchie ebenfalls Knoten befinden, die in der ursprünglichen Treffermenge enthalten sind.
Trifft dies zu, wird der jeweils allgemeinere Knoten, also derjenige, der höher in der Hierarchie steht, aus der Ergebnismenge entfernt, sodass nur die spezifischeren Varianten verbleiben.
Zusätzlich wird überprüft, ob ein Knoten ausschließlich Basen besitzt, die selbst keine Treffer sind.
In einem solchen Fall wird der Knoten ebenfalls ausgeschlossen, da er sich auf keine ausreichend spezifische Grundlage stützt.

\begin{lstlisting}[language=Java,caption={Methode \texttt{filterByInheritance}},label=lst:impl-filterByInheritance,basicstyle=\ttfamily\scriptsize]
private Set<RepGraphNode> filterByInheritance(Set<RepGraphNode> matches, RepMatchingContext context) {
    if (matches.isEmpty()) return matches;

    Map<RepGraphNode, Collection<RepGraphNode>> baseMap = new HashMap<>();
    for (RepGraphNode node : matches)
        baseMap.put(node, node.traverse(OUTGOING_INHERITANCE_ARTIFACT_NODE_QUERY).values());

    final Set<RepGraphNode> toRemove = new HashSet<>();
    for (RepGraphNode node : matches) {
        Stack<RepGraphNode> stack = new Stack<>();
        Set<RepGraphNode> seen = new HashSet<>();
        stack.push(node);
        seen.add(node);
        while (!stack.isEmpty()) {
            for (RepGraphNode base : baseMap.getOrDefault(stack.pop(), Collections.emptyList())) {
                if (!seen.add(base)) continue;
                if (matches.contains(base)) {
                    toRemove.add(base);
                    stack.push(base);
                } else {
                    toRemove.add(node);
                    stack.clear();
                    break;
                }
            }
        }
    }

    if (context != null)
        toRemove.forEach(n -> context.getTrace(n).markFilteredByInheritance());

    return matches.stream().filter(n -> !toRemove.contains(n)).collect(Collectors.toSet());
}
\end{lstlisting}

\subsubsection{Anwendung der gefundenen Knoten auf Artefakte}

Die identifizierten Knotenpunkten werden nun mit der \texttt{applyToArtifact()}-Methode auf das Quellartefakt angewendet.
Wie in \autoref{subsubsec:model-result-processing-apply-nodes-to-artifact} beschrieben, implementiert die Klasse \texttt{RepGraphNode} eine Methode \texttt{collectApplyNodes()}, die rekursiv alle erreichbaren Knoten sammelt und dabei den Kontext mit Informationen über den Pfad und die gesammelten Transformationen verwaltet.
Die innere Klasse \texttt{ApplyContext} kapselt diesen Kontext und bietet Methoden zur Prüfung der Anwendbarkeit von Transformationen und zur Bestimmung des effektiven Beziehungstyps.

Für jeden Knotentyp gibt es spezifische Implementierungen der \texttt{applyToArtifact()}-Methode, die die typspezifischen Attribute auf das Zielartefakt anwenden.
Beispielsweise fügt die \texttt{RepCpeNode}-Klasse wie in \autoref{lst:impl-cpe-applyToArtifact} zu sehen, bei einer positiven Beziehung die CPE zu den \texttt{Additional CPE URIs} des Artefakts hinzu und entfernt sie aus den \texttt{Inapplicable CPE URIs}, während bei einer negativen Beziehung das Gegenteil geschieht.
Die Transformationen werden zunächst ausgewertet, um optional einige Attribute der \acrshort{cpe} zu ersetzen oder den Beziehungstyp zu überschreiben.

\begin{lstlisting}[language=Java,caption={Methode \texttt{applyToArtifact} in \texttt{RepNodeCpe}},label=lst:impl-cpe-applyToArtifact,basicstyle=\ttfamily\scriptsize]
protected void applyToArtifact(Artifact artifact, ApplyContext applyContext) {
    String applyCpe = this.cpe;
    List<RepEdgeTransform> activeTransforms = applyContext.getActiveTransforms(this);
    if (!activeTransforms.isEmpty()) {
        Cpe parsedCpe = parseCpe(this.cpe);
        for (RepGraphEdge.RepEdgeTransform transform : activeTransforms) {
            parsedCpe = createTransformer(transform.getTransformProps()).apply(parsedCpe);
        }
        applyCpe = parsedCpe.toString();
    }

    RelationshipSubType subType = applyContext.getEffectiveRelSubType(activeTransforms);
    if (subType == REPRESENTED_BY) {
        removeValue(artifact, INAPPLICABLE_CPE, applyCpe);
        appendValue(artifact, ADDITIONAL_CPE, applyCpe);
    } else if (subType == NOT_REPRESENTED_BY) {
        removeValue(artifact, ADDITIONAL_CPE, applyCpe);
        appendValue(artifact, INAPPLICABLE_CPE, applyCpe);
    }
}

private Function<Cpe, Cpe> createTransformer(Map<String, String> transforms) {
    return original -> {
        final CpeBuilder builder = builder().from(original);
        for (Entry<String, String> entry : transforms.entrySet()) {
            final String field = entry.getKey();
            final String value = entry.getValue();
            switch (field.toLowerCase()) {
                case "part" -> builder.part(Part.getEnum(value));
                case "vendor" -> builder.vendor(value);
                case "product" -> builder.product(value);
                case "version" -> builder.version(value);
                case "update" -> builder.update(value);
                case "edition" -> builder.edition(value);
                case "language" -> builder.language(value);
            }
        }
        return builder.build();
    };
}
\end{lstlisting}

\subsection{Integration in das bestehende System}\label{subsec:impl-integration}

Die Integration des neuen Korrelationssystems in das bestehende Schwachstellenmanagement erfolgt über das System der sogenannten \enquote{Inventory Enrichment Pipeline}, über die das aktuelle Schwachstellenmanagement ausgeführt wird.
Um auch das Korrelationssystem dafür verfügbar zu machen, wird es als zusätzlicher Schritt in der Verarbeitungspipeline eingebunden.
Zunächst wird das alte Korrelationssystem als Schritt beibehalten, um in der Übergangsphase erst nach und nach die alten \acrshort{yaml}-Dateien in das neue Format übersetzen zu müssen.
