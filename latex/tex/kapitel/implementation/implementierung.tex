\section{Implementierung und Integration}\label{sec:implementierung}

Das in \autoref{sec:model-modellierungsansatz} entworfene Modell des neuen Korrelationssystems sollte als Teil der Arbeit als Nachweis für die Realisierbarkeit als Java-Applikation in das bestehende Code-Repository implementiert werden.
Dazu werden zunächst die technischen und architekturellen Entscheidungen aufgeführt, dann die Implementierung vorgestellt.

\subsection{Technische Grundentscheidungen}\label{subsec:impl-tech-choices}

Bei der Implementierung des neuen Korrelationssystems wurden mehrere technische Grundentscheidungen aus den Anforderungen und Rahmenbedingungen des Projekt- und Firmenkontexts getroffen, auf denen das Modell implementiert werden soll.

\paragraph{Programmiersprache}

Als Programmiersprache wurde Java in der Version 8 gewählt, da das bestehende Schwachstellenmanagement der \metaeffektsp in dieser Sprache und Version implementiert ist und das neue Korrelationssystem sich damit integrieren können muss.
Das Ökosystem von Java bietet zudem eine umfangreiche Liste an Bibliotheken über das Repository von Maven Central\footnote{\url{https://search.maven.org}} für alle Nutzungskontexte und das robuste Typsystem mit Unterstützung für Generics wird die Entwicklung der Datenstrukturen für den Korrelationsgraphen vereinfachen.

\paragraph{Datenbanktechnologie}

Für die persistente Speicherung des Korrelationsgraphen wurde SQLite\footnote{\url{https://sqlite.org}} als relationale Datenbank aufgrund von mehreren Faktoren ausgewählt.
SQLite benötigt keinen separaten Datenbankserver, sondern speichert die gesamte Datenbank in einer einzigen Datei, was die Verwaltung, Sicherung, Auslieferung und den Einsatz auf der Seite von Kunden stark vereinfacht.

Als relationale Datenbank muss von Anfang an ein einheitliches Schema für die Tabellen definiert werden.
Die Kernattribute der Datenelemente werden als dedizierte Attribute in den Spalten der Tabellen abgelegt.
Um aber für zukünftige Formatänderungen vorzusorgen, und um die stark typabhängigen zusätzlichen Attribute in den Spalten vernünftig zur serialisierung und deserialisierung abspeichern zu können, wird einfach das gesamte Datenobjekt als \acrfullr{json}-Objekt in einer zusätzlichen Spalte abgelegt und bei Bedarf ausgelesen.
Das ermöglicht eine flexible Erweiterung der Attribute ohne Schemaänderungen und dank Funktionen wie \texttt{json\_extract}\footnote{\url{https://sqlite.org/json1.html}} von SQLite kann dennoch bei Bedarf auf Attribute in den Objekten über \acrfullr{sql} zugegriffen.

Alternativen, die in Betracht gezogen wurden, sind:

\begin{itemize}
    \itemsep0em
    \item Ein Lucene-Index\footnote{\url{https://lucene.apache.org}}, da Apache Lucene bereits im Projektumfeld für die performante Speicherung anderer Schwachstellendaten genutzt wird und eine sehr schnelle Volltextsuche auf strukturierter und unstrukturierten Information erlaubt.
    Jedoch wäre nicht nur das Verteilen der Datenbank komplizierter, da es sich um einen Ordner an Dateien handelt der zunächst komprimiert und entkomprimiert werden müsste, sondern auch das iterative Arbeiten mit dem Index wäre schwerer, da bei diesem nicht einfach eine Datei als Backup verwendet werden könnte, die die Arbeitsversion einfach überschreiben könnte, sondern ein ganzer Ordner ersetzt werden muss.
    \item Die direkte Speicherung der Daten als \acrshort{json}-Dateien auf dem Dateisystem, was die einfachste Version ist, da es keine weiteren Treiber oder Bibliotheken bedarf.
    Diese Option wurde verworfen, da sie keine effiziente Abfrage bereitstellt und dementsprechend nicht skalierbar genug ist und zudem Integritätsgarantien fehlen.
    \item Der Einsatz einer dokumentenorientierten NoSQL Datenbank wie MongoDB\footnote{\url{https://www.mongodb.com}}, welche native JSON-Speicherung und flexible Schemata bietet.
    Aufgrund des Overheads durch eine zusätzliche Serverkomponente und Lizenzüberlegungen wurde diese Lösung nicht weiterverfolgt.
\end{itemize}

\paragraph{Bibliotheken und Frameworks}

Für die Implementierung wurden verschiedene Bibliotheken eingesetzt, um die Entwicklung zu beschleunigen:

\begin{itemize}
    \itemsep0em
    \item Gson\footnote{\url{https://github.com/google/gson}}: Für die \acrshort{json}-Serialisierung und -Deserialisierung der Knoten- und Kantendaten.
    \item Guava\footnote{\url{https://github.com/google/guava}}: Bietet erweiterte Datenstrukturen und Hilfsmethoden, vor allem für das Caching von Abfrageergebnissen.
    \item Apache Commons\footnote{\url{https://commons.apache.org}}: Stellt Hilfsfunktionen für die Datei- und Stringverarbeitung bereit.
    \item Lombok\footnote{\url{https://projectlombok.org}}: Reduziert Boilerplate-Code durch Annotation-basierte Codegenerierung für Getter, Setter und weitere Methoden.
    \item Für die Verarbeitung von diversen Datentypen wurden spezialisierte Bibliotheken integriert, wie die Bibliothek \texttt{us.springett.parsers.cpe}\footnote{\url{https://github.com/stevespringett/cpe-parser}} um \acrshort{cpe}-Strings zu verarbeiten.
\end{itemize}

\subsection{Architekturübersicht}\label{subsec:impl-arch-overview}

Das Korrelationssystem wird über mehrere Klassen implementiert, um die Erstellung, Verwaltung und Abfrage des Graphen zu ermöglichen.
Um Namenskonflikte zwischen anderen Modulen zu vermeiden und um ein einheitliches Namensschema zu definieren, werden alle relevanten Klassen mit \enquote{Rep} als Präfix gekennzeichnet.

\subsubsection{Kernkomponenten}

Die in dieser Sektion beschriebenen Klassen können in einem Klassendiagramm in \autoref{fig:impl-class-diagram-core-model} gefunden werden.

\begin{figure}[htbp]
    \centering
    \makebox[\textwidth]{\includesvg[width=1.3\textwidth, inkscapelatex=false]{bilder/impl-class-diagram-core-model}}
    \caption{Klassendiagramm der Kernkomponenten}
    \label{fig:impl-class-diagram-core-model}
\end{figure}

Die zentrale Klasse \texttt{RepGraph} repräsentiert den Korrelationsgraphen und bietet Methoden zum Zugriff auf Knoten und Kanten.
Sie verwaltet über eine Klasse \texttt{DbConnectionProvider} die Datenbankverbindung, stellt sicher, dass die Verbindung korrekt initialisiert und verwaltet wird und führt die SQL-Operationen aus, die für die Graphmanipulation erforderlich sind.
Die Klasse implementiert auch Methoden zur Sicherung und Wiederherstellung von Backups des Graphen.

Um eine klare Trennung der Manipulation des Graphen und der Abfragelogik zu haben, wird eine Klasse \texttt{RepGraphQuery} eingeführt, die Methoden zur Traversierung und Filterung des Graphen bereitstellt.
Die Klasse nutzt das \enquote{Weak References}-Feature der Caching-Mechanismen die Guava bereitstellt, um die Leistung bei wiederholten Abfragen zu verbessern und trotzdem vom Java Garbage Collector profitiert, um nicht erreichbare Instanzen aufzuräumen \autocite{GuavaCachesExplained}.

Das Knotenmodell wird durch eine Hierarchie von Klassen repräsentiert, die von der abstrakten Basisklasse \texttt{RepGraphNode} abgeleitet werden.
Jeder Knotentyp (\acrshort{cpe}, \acrshort{purl}, Artefakt, Produkt usw.) wird durch eine spezialisierte Klasse implementiert, die die spezifischen Attribute und Verhaltensweisen des jeweiligen Typs kapselt.
Die Klasse \texttt{RepCpeNode} beispielsweise implementiert die Logik für \acrshort{cpe}-Knoten, einschließlich der Verarbeitung von CPE-Strings und der Anwendung von Transformationen.
Ähnlich implementiert \texttt{RepArtifactNode} die Logik für Artefaktknoten, einschließlich der Matching-Algorithmen für die Identifikation von Artefakten.

Um die programmatische Traversierung des Graphen für Abfragen möglichst einfach zu gestalten, werden in jedem Knoten die von diesem aus erreichbaren Knoten zusammen mit ihren Kanten in einer Liste als Attribut abgelegt.
Diese Liste wird implizit erst bei dem ersten Zugriff auf referenzierte Knoten befüllt, um nicht automatisch rekursiv ganze Inseln im Graphen abzufragen.
Ein weiterer Vorteil, einen Cache für die Instanziierung der Knoten und Kanten zu verwenden ist, dass bei zyklischen Verbindungen oder erneuten Zugriffen diese Liste nicht neu berechnet werden muss, und für einen konkreten Knoten die Instanz immer die selbe sein wird.
Der Datenkonstruktor hat zwei Betriebsmodi \enquote{Read-Only} und \enquote{Read/Write}, wobei der Cache nur in dem Lesemodus verwendet wird, um zusichern zu können, dass immer der aktuelle Datensatz aus der Datenbank zurückgegeben wird.

Kanten werden durch die Klasse \texttt{RepGraphEdge} repräsentiert, die Informationen über Quell- und Zielknoten und Beziehungstyp, sowie Metadaten enthält.
Die Klasse implementiert auch die Logik für die Anwendung von Transformationen, die entlang der Kanten propagiert werden.

% Über diese Liste an Referenzen zu anderen Knoten können nun beliebige komplexe Abfragen gebaut werden.

\subsubsection{Datenbankschema}

Zum Programmstart wird sichergestellt, dass die Datenbank die nötigen Tabellen, Spalten und Indizes enthält.
Das \acrshort{sql}-Skript mit dem entsprechenden Schema kann in \autoref{lst:create-node-table-sql} gefunden werden.
Neben den vollständig als \acrshort{json} serialisierten Datenobjekten enthält die \texttt{nodes}-Tabelle die Knoten mit einer eindeutigen Id und einem Knotentyp und die \texttt{edges}-Tabelle Kanten mit Quell- und Zielknoten-Ids, Richtung, Beziehungstyp.

\lstinputlisting[
    firstline=1,
    language=SQL,
    caption={Datenbankschema aus \texttt{create-node-table.sql}},
    label=lst:create-node-table-sql,
    basicstyle=\ttfamily\scriptsize
]{code/create-node-table.sql}

\subsubsection{Modifikationssystem}

Das Modifikationssystem ermöglicht die Änderung des Graphen durch verschiedene Quellen, sei es automatisiert oder auch manuell.
Die zuständigen Klassen sind im Klassendiagramm in \autoref{fig:impl-class-diagram-modifiers} zu finden.

\begin{figure}[htbp]
    \centering
    \makebox[\textwidth]{\includesvg[width=1\textwidth, inkscapelatex=false]{bilder/impl-class-diagram-modifiers}}
    \caption{Klassendiagramm der Modifikationsklassen}
    \label{fig:impl-class-diagram-modifiers}
\end{figure}

Die Klasse \texttt{RepGraphModifierEntry} ist die Basisklasse für Modifikationsanweisungen und ist dafür verantwortlich, sie auf den Graphen anzuwenden.
Wie in \autoref{subsec:model-graph-modification} beschrieben unterstützt sie mit den verschiedenen Modi die Erwartungshaltung an den Graphen auszudrücken und arbeitet allgemein inkrementell auf den Daten.
Um eine Menge an Modifikationseinträgen auf den Graphen anzuwenden wird das System in zwei Phasen aufgeteilt und wird anhand vom Pseudocode in \autoref{lst:modifikation-pseudocode} erklärt.

In der ersten Phase wird für jeden Eintrag der Graph nach dem Knoten mit dem eindeutigen Typ und Id-Paar durchsucht, um je nach \texttt{ModificationType} das Prüfen der Knotenexistenz durchzuführen und den Knoten optional anzulegen.
Diese erste Phase sorgt dafür, dass alle referenzierten Knoten instanziiert sind, sodass in der nächsten Phase die Relationen zwischen diesen korrekt aufgebaut werden können.
In der zweiten Phase werden die Knotenattribute und Kanten in drei getrennten Schritten befüllt.
Zunächst werden in \texttt{baseModification} einige Basisattribute ausgewertet, die für alle Knotentypen gültig sind, wie Namensräume und Metadaten.
Die Methode \texttt{processRelations} verarbeitet dann alle konfigurierten Relationen.
Schließlich wird die \texttt{implementationSpecificModification} ausgeführt, in der je nach Knotentyp weitere Attribute aufgefüllt werden und dann wird der aktualisierte Knoten mit \texttt{graph.insertOrUpdateNode} persistiert.

\begin{lstlisting}[language=pseudo,caption={Ablauf des Modifikationssystems für eine Menge an Modifikationen},label=lst:modifikation-pseudocode,basicstyle=\ttfamily\scriptsize]
FOR EACH entry IN entries DO
    node := graph.findNode(entry.nodeType, entry.nodeId)
    IF entry.mode == CREATE AND node EXISTS THEN
        THROW "Node exists"
    ELSE IF (entry.mode == RESET OR APPEND) AND node DOES NOT EXIST THEN
        THROW "Node missing"
    END IF
    graph.ensureExists(entry)
END FOR

FOR EACH entry IN entries DO
    node := graph.findNode(entry.nodeType, entry.nodeId)
    entry.baseModification(graph, node)
    entry.processRelations(graph, node)
    entry.implementationSpecificModification(graph, node)
    graph.insertOrUpdateNode(node, (old, new) --> new)
END FOR
\end{lstlisting}

\paragraph{RepContributor}

Die abstrakte Klasse \texttt{RepContributor} definiert über einen einheitlichen Mechanismus die Struktur für verschiedene Datenquellen, die Daten zum Korrelationsgraphen beitragen wollen.
Die Implementierungen stellen fast alle die automatischen Anteile dar, die \acrshortpl{vdb} oder anderen Datenquellen automatisch auswerten, um Informationen abzuleiten.
Allerdings gibt es natürlich die eine Implementierung, die das manuelle \acrshort{yaml}-Format auswertet und auf den Graphen anwendet.
Dieser manuelle Contributor ist der letzte, der ausgeführt wird, um sicherzustellen, dass alle vorherigen Contributors durch den manuellen korrigiert werden können.

Auch wenn jede Implementierung sich auf andere Daten- und Knotentypen bezieht, funktionieren alle nach demselben Muster:
Zunächst wird die entsprechende Datenquelle analysiert, um die betreffenden Datenobjekte zu finden, die als Knoten repräsentiert werden sollen.
Mit diesen werden programmatisch Modifikatoren für den Graphen zusammengestellt und erst ganz zum Schluss wird die Methode aufgerufen, die die Modifikationen einheitlich auf den Graphen anwendet.

Ein Beispiel ist der \texttt{CpeDictionaryRepContributor}, der als erster Contributor das offizielle \acrshort{cpe}-Dictionary des \acrshort{nist} vollständig importiert, um alle \acrshort{cpe}-Knoten mit ihren Metadaten einzufügen.
Diese Klasse durchsucht den \acrshort{cpe}-Index nach Vendor-Produkt-Paaren und extrahiert die zugehörigen Metadaten wie Titel und Beschreibungen, um sie als Knoten im Graphen anzulegen.

Mit dem \texttt{RepGraphModifierParser}, der für das rekursive Einlesen von \acrshort{yaml}-Dateien zuständig ist, wird der \texttt{FileRepContributor} implementiert.
Er konvertiert die \acrshort{yaml}-Struktur in \texttt{RepGraphModifierEntry}-Objekte, die dann auf den Graphen angewendet werden können.
Fehler beim Parsing werden mit aussagekräftigen Meldungen mit Referenzen auf die originale Datei und die Zeile des Eintrags in der Datei protokolliert, um die Fehlersuche zu erleichtern.
