# Software Identification Ecosystem Option Analysis

## MAKE IDENTIFIERS AVAILABLE WHEN AND WHERE NEEDED

> For example, common platform enumeration (CPE) identifiers are often not created until after vulnerabilities are
> discovered in a piece of software. As a result, the initial vulnerability report is generally unable to include a CPE
> identifier and cannot support correlation based on CPE identifiers.

> While some identifier schemas have a built-in mechanism by which identifiers are made available with the associated
> software (for example, Universal Bill of Receipts (OmniBOR) and software identification (SWID) tags), others lack a
> simple process by which to learn the identifier for a piece of software.

> The distinguishing feature between the paths lies in when and by whom the identifiers are generated. In one path,
> called “Inherent identifiers,” identifiers can be generated by any party at any time. This is possible because these
> identifiers are mechanically generated based on the inherent properties of a piece of software available to anyone
> possessing that piece of software.

> In the second path, called “Defined identifiers”, identifiers are created only by certain parties and only at one
> point in time. These parties assert an association between an identifier and some piece of software, and then must
> publish this association so that others can use it.

### Inherent Identifiers

> An inherent identifier is a software identifier that any party can deterministically derive from an instance of a
> piece of software. For example, OmniBOR (formerly GitBOM) creates identifiers from the SHA1 or SHA256 hash of file
> information. The key criterion for inherent identifiers is that there is a mechanical process that any party can
> perform. An identifier scheme is not “inherent” if knowledge is dependent upon certain parties or if different parties
> have different understandings of the input.

Problems:

> First, it isn’t always obvious which file(s) should be the input to the identifier generation function for large,
> multi-file applications. Large applications often have a “launcher” executable file that is the front-end to multiple
> other executables and libraries. However, when an application gets a new revision, the launcher does not always
> change, so if the application launcher is the only input to the identifier generation function, multiple versions of
> the same piece of software might get the same identifier. This can be addressed by using multiple files as the input
> to
> the identifier generation function, but defining which files should serve as inputs in a way that all parties will
> understand can be difficult.
> To ensure all parties create the same software identifier for the same piece of software, there must be a reliable
> method of ensuring that all parties always use the same set of files as inputs, while ensuring that any files that may
> differ between installations of the same variant of the software are excluded.
> https://omnibor.io/docs/artifact-ids

> The second challenge is that most of the properties that describe and organize software are not “inherent.” People
> discuss software using its name, vendor, version, and a few other properties; but these are labels that some party
> applies to the software, rather than inherent properties of software files. The result is that inherent identifiers
> are often not easily understood or used by human readers.

As I see it, inherent identifiers are identifiers that can be determined solely on the files of a library, software,
etc. without the need of a declarative authority that determines an explicit identifier for it.
The following possible identifiers come to mind:

- Hashes based on the file(s) (see process and issues above, also usually not present in vulnerability databases)
- PURLs for packages installed from package managers, which usually provide enough metadata to obtain the PURL
  (only works for packages published on common package managers, variants, ...)

#### Expected Path Outcomes

> Identifier discovery is streamlined because personnel can create identifiers as needed, rather than looking them up
> from other sources. Likewise, there would be no issues around the sufficiency of identifier coverage, as there would
> be no software for which identifiers personnel could not create identifiers. Even legacy or custom, in-house
> applications would have a unique identifier that users could use in any context.

### Defined identifiers

#### Background on Cluster of Paths Around Defined identifiers

> A defined identifier is an identifier that some party declares is associated with a particular piece of software. A
> designated party asserts the binding between identifier and software. Other parties wishing to use an identifier for a
> given piece of software need to be informed of the associated identifier. Defined identifiers are the alternative to
> inherent identifiers.

> There are many existing defined identifier formats, including CPE, purls, and SWID tags.
> CPEs consist of several fields reflecting properties of the software in question, SWID tag identifiers that are
> Globally Unique Identifiers (GUIDs), and purls that are uniform resource identifiers (URIs) whose structures vary
> depending on the software’s package management system.

Current defined identifier formats face two significant challenges in creating a broad and robust software identifier
ecosystem:

> Some party or parties need to take on the role of asserting the bindings between identifiers and software. This paper
> refers to such parties as “identifier generators.” Because a piece of software does not have any software identifier
> until an authority asserts one for it, identifier generators need to assert these bindings at a rate that, ideally,
> keeps up with the rate at which software variants (versions, editions, etc.) are produced, or at least the rate at
> which
> they are referenced in data artifacts. Within certain environments, this has been achieved. For example, package
> management systems automatically provide a unique identifier for every package within their purviews. However,
> software
> identification schemes that cover all global software continue to struggle with providing sufficient, timely coverage.

> The parties that wish to tag artifacts with software identifiers need a way to learn the identifier associated with a
> given piece of software. There are different ways that this can be accomplished: SWID tag identifiers travel with the
> software itself, while CPEs are stored in a central, searchable database. Regardless of the method, there must be some
> low-effort mechanism that allows one to reliably learn the identifier for a given piece of software.

... which is not given for CPEs and others.

## Things you must look out for if different parties create identifiers, these are real existing issues

False-Positives via **identifier reuse**:

> The identifier format must define a way for all identifier creators to specifically denote the identifiers they
> create. The denotations must be reconciled to ensure that two different identifier creators will never accidentally
> assign the same identifier to different pieces of software. Such an occurrence (called “identifier reuse”) could lead
> to
> false-positive correlations and must be avoided.

False-Negatives via **overidentification**:

> The converse of identifier reuse is called “overidentification” and occurs when multiple software identifiers are
> created for a single piece of software. Overidentification is problematic because it leads to false-negative
> correlations if two data artifacts for the same piece of software are tagged with different identifiers.

## Sharing identifiers

They do not believe that there should be a central party that controls an instance where all identifiers are collected,
since that would be impractical on a larger scale; both for having everyone register their software, but also for the
software to be looked up.

This cannot be requested of the identity generators either, since they are probably already busy creating the
identifiers and not willing to contribute much more, since all this is just overhead to them that serves no additional
purpose.

Instead, they want to share the identifiers with the software:

> Push identifiers with software: After identifiers are created, there must be a way for other parties to learn them so
> that data artifacts can be correctly tagged. In a highly distributed identifier generation environment, having each
> identifier generator host a database with which personnel can look up identifiers is not practical—hosting such a
> service reliably may be beyond the means of some identifier generators, and it creates challenges for users who would
> need to figure out which database to use to find a given identifier. A central database of identifiers is only
> practical
> if all identifier generators are pushing their identifiers to this database, but this means there must be coordination
> with a central authority, the avoidance of which is the primary goal of this model. Instead, for users to obtain
> identifiers would likely be to push them out with the software with which they are associated.

In order for this new format to be accepted, the identifiers must be as simple as possible.

> Minimize required information in identifiers: The most critical factor for this model will be getting enough parties
> to generate accurate identifiers to cover a critical mass of the global software space. Every piece of information the
> identifier format requires potentially increases the workload for identifier generators and creates opportunities for
> errors.

## Adoption and Future

> This model aims to maximize coverage of the global software space by leveraging as large a cadre of parties as
> possible creating software identifiers. This is facilitated by minimizing the burdens associated with software
> identifier generation (removal of the burdens of external coordination and simplification of identifier generation)
> while creating incentives for cooperation. The degree to which the software space is covered will be the biggest
> challenge for this model and its primary measure of success.

> Assuming the coverage of the global software space is adequate, creating and pushing identifiers with software items
> would ensure identifier availability timeliness. As noted earlier, a common complaint about the CPE identifier scheme
> is that identifiers are generally created only after there is a demonstrated need, which is too late for their
> inclusion in initial data artifacts. By contrast, because identifiers are created at the software source in this
> model, they would be co-temporal with their associated software, thus eliminating this time gap between need and
> creation.

## Managed, Distributed Model

> In the model this path describes, a central authority supports and coordinates the activities of multiple software
> identifier creators. The duties of the authority could include some combination of the following:  
> • Assigning responsibility to create identifiers for certain sets of software.  
> • Providing a searchable central repository of identifiers.  
> • Identifying issues with the identifier space (e.g., identifier reuse, overidentification, critical gaps in coverage)
> ~ and reconciling them.
> Like the model in section 2.2, this model relies on a distributed community of identifier
> generators. However, in this model, there is a central authority that oversees those activities. The authority
> supports the community by helping to ensure quality, availability, and sufficient coverage of identifiers. This,
> however, requires identifier producers to coordinate with the authority, which increases the burden on identifier
> generators. Automation could help reduce this burden on generators to nearly nothing, but it may still deter some
> parties from participating as identifier generators. Likewise, the authority itself will need to be provided with
> sufficient resources to avoid becoming a bottleneck for the community.

## Conclusion

> There are two key requirements for an effective software identification ecosystem:
> 1) Availability of software identifiers (that is, labels for specific versions of software items, such as an
     applications, libraries, etc. which conform to a defined format).
> 2) Software identifiers that support both precise (i.e., a single software variant) and broad (that is, a large range
     of software variants).

Other factors:

> If defined identifiers (i.e., identifiers created only by certain parties and only at one point in time) are used,
> identifier generators (i.e., organizations who create identifiers) will need to capture certain common properties of
> software (e.g., name, version, architecture). This information is necessary to support data artifacts that apply to
> groups of software, such as CVE Records.

> Without a central authority, the quality of identifiers (and thus the quality of the correlations supported) will
> depend on the individual efforts of the identifier generator community.

> Only adoption of inherent identifiers (i.e., those that can be generated by any party at any time via the artifact
> itself) will remove the need for a large community of identifier generators.

## Possible Options for the direct future

- If the community wishes to pursue Inherent Identifiers, then OmniBOR provides a strong starting point. This requires
  research how non-inherent properties (such as software name, vendor, and version) could be mechanically collected and
  used to provide the properties needed for grouping expressions.  
  The National Software Reference Library (NSRL) provides a template for such an endeavor, although such an effort is
  likely not scalable.  
  https://www.nist.gov/itl/ssd/software-quality-group/national-software-reference-library-nsrl/nsrl-download/current-rds
- If the community wishes to pursue Defined Identifiers with Grouping Expressions, then CPE’s existing applicability
  language already provides a robust grouping expression capability. CPE’s challenge would be evolving to a more
  distributed production model to address scalability and sustainability challenges. Alternately (or concurrently), purl
  could be the basis of a solution. purl already supports a distributed creation model but would need to be expanded to
  cover software beyond those distributed in packages and to embed necessary information.
- If the community wishes to pursue Defined Identifiers with More Comprehensive Enumeration Support (e.g., searchable
  database), then purl is a promising starting point due to its existing mechanisms for distributed identifier
  generation. The scope of purl’s supported software would need to be broadened beyond just packaged software and the
  tools that generate purls would need to add a step to register all identifiers with a central authority. Likewise, all
  parties would require reliable access to the database needed to map identifiers against range queries.
